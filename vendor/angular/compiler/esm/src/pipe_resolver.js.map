{"version":3,"file":"pipe_resolver.js","sourceRoot":"","sources":["../../../../../modules/@angular/compiler/src/pipe_resolver.ts"],"names":[],"mappings":";AAAA,uBAAqE,eAAe,CAAC,CAAA;AAErF,+BAA8B,iBAAiB,CAAC,CAAA;AAEhD,uBAAyC,oBAAoB,CAAC,CAAA;AAC9D,6BAA4B,0BAA0B,CAAC,CAAA;AACvD;;;GAGG;AACH,yBAAyB,IAAS;IAChC,MAAM,CAAC,IAAI,YAAY,mBAAY,CAAC;AACtC,CAAC;AACD;IAEA;;OAEG;IACH,YAAY,UAA4B;QACpC,EAAE,CAAC,CAAC,gBAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC1B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC/B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,UAAU,GAAG,gBAAS,CAAC;QAC9B,CAAC;IACH,CAAC;IACH;;;;OAIG;IACH,OAAO,CAAC,IAAU;QACd,IAAI,gBAAgB,CAAC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,wBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;QAClF,EAAE,CAAC,CAAC,gBAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACrB,IAAI,gBAAgB,CAAC,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YAC9D,EAAE,CAAC,CAAC,gBAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC1B,MAAM,CAAC,UAAU,CAAC;YACpB,CAAC;QACH,CAAC;QACD,MAAM,IAAI,0BAAa,CAAC,8BAA8B,gBAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC3E,CAAC;IAED,OAAO,8BAA8B;QACtC,gBAAgB;QACjB,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC;IAChC,CAAC;AAQH,CAAC;AANM,uBAAU,GAA0B;IAC3C,EAAE,IAAI,EAAE,iBAAU,EAAE;CACnB,CAAC;AACF,kBAAkB,CAAQ,2BAAc,GAA2D;IACnG,EAAC,IAAI,EAAE,8BAAe,GAAG;CACxB,CAAC;AAtCW,oBAAY,eAuCxB,CAAA;AAE2B,6BAAqB,GAAG,IAAI,YAAY,CAAC,gBAAS,CAAC,CAAC","sourcesContent":["import {resolveForwardRef, Injectable, PipeMetadata, reflector} from '@angular/core';\n\nimport {ReflectorReader} from '../core_private';\n\nimport {Type, isPresent, stringify} from '../src/facade/lang';\nimport {BaseException} from '../src/facade/exceptions';\n/**\n * @param {?} type\n * @return {?}\n */\nfunction _isPipeMetadata(type: any): boolean {\n  return type instanceof PipeMetadata;\n}\nexport class PipeResolver {\nprivate _reflector: ReflectorReader;\n/**\n * @param {?=} _reflector\n */\nconstructor(_reflector?: ReflectorReader) {\n    if (isPresent(_reflector)) {\n      this._reflector = _reflector;\n    } else {\n      this._reflector = reflector;\n    }\n  }\n/**\n *  Return {@link PipeMetadata} for a given `Type`.\n * @param {?} type\n * @return {?}\n */\nresolve(type: Type): PipeMetadata {\n    var /** @type {?} */ metas = this._reflector.annotations(resolveForwardRef(type));\n    if (isPresent(metas)) {\n      var /** @type {?} */ annotation = metas.find(_isPipeMetadata);\n      if (isPresent(annotation)) {\n        return annotation;\n      }\n    }\n    throw new BaseException(`No Pipe decorator found on ${stringify(type)}`);\n  }\n\n  static _tsickle_typeAnnotationsHelper() {\n /** @type {?} */\nPipeResolver.prototype._reflector;\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */ static ctorParameters: {type: Function, decorators?: DecoratorInvocation[]}[] = [\n{type: ReflectorReader, },\n];\n}\n\nexport var /** @type {?} */ CODEGEN_PIPE_RESOLVER = new PipeResolver(reflector);\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}