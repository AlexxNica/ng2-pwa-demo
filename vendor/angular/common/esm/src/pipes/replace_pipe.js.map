{"version":3,"file":"replace_pipe.js","sourceRoot":"","sources":["../../../../../../modules/@angular/common/src/pipes/replace_pipe.ts"],"names":[],"mappings":";AAAA,uBAA8C,eAAe,CAAC,CAAA;AAE9D,uBAOO,uBAAuB,CAAC,CAAA;AAE/B,kDAA2C,mCAAmC,CAAC,CAAA;AAC/E;IACA;;;;;OAKG;IACH,SAAS,CAAC,KAAU,EAAE,OAAwB,EAAE,WAA8B;QAC1E,EAAE,CAAC,CAAC,cAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACnB,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;QAED,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACjC,MAAM,IAAI,8DAA4B,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;QAC7D,CAAC;QAED,IAAI,gBAAgB,CAAC,KAAK,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;QAE9C,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACrC,MAAM,IAAI,8DAA4B,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;QAC/D,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YAC7C,MAAM,IAAI,8DAA4B,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;QACnE,CAAC;QACD,sDAAsD;QACtD,iFAAiF;QAEjF,EAAE,CAAC,CAAC,iBAAU,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,gBAAgB,CAAC,UAAU,GAAG,eAAQ,CAAC,OAAO,CAAC,GAAG,oBAAa,CAAC,MAAM,CAAE,gBAAgB,CAAA,CAAU,OAAQ,CAAC,CAAC,GAAmB,CAAW,OAAQ,CAAC,CAAC;YAExJ,MAAM,CAAC,oBAAa,CAAC,gBAAgB,CAAC,KAAK,EAAE,UAAU,EAAE,gBAAgB,CAAA,CAAa,WAAY,CAAC,CAAC,CAAC;QACvG,CAAC;QACD,EAAE,CAAC,CAAC,OAAO,YAAY,MAAM,CAAC,CAAC,CAAC;YAC9B,6BAA6B;YAC7B,MAAM,CAAC,oBAAa,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,EAAE,gBAAgB,CAAA,CAAW,WAAY,CAAC,CAAC,CAAC;QAC5F,CAAC;QAED,MAAM,CAAC,oBAAa,CAAC,OAAO,CAAC,KAAK,EAAE,gBAAgB,CAAA,CAAW,OAAQ,CAAC,EAAE,gBAAgB,CAAA,CAAW,WAAY,CAAC,CAAC,CAAC;IACtH,CAAC;IACH;;;OAGG;IACK,eAAe,CAAC,KAAU,IAAa,MAAM,CAAC,eAAQ,CAAC,KAAK,CAAC,IAAI,eAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3F;;;OAGG;IACK,iBAAiB,CAAC,OAAY;QAClC,MAAM,CAAC,eAAQ,CAAC,OAAO,CAAC,IAAI,OAAO,YAAY,MAAM,CAAC;IACxD,CAAC;IACH;;;OAGG;IACK,qBAAqB,CAAC,WAAgB;QAC1C,MAAM,CAAC,eAAQ,CAAC,WAAW,CAAC,IAAI,iBAAU,CAAC,WAAW,CAAC,CAAC;IAC1D,CAAC;AAKH,CAAC;AAJM,sBAAU,GAA0B;IAC3C,EAAE,IAAI,EAAE,WAAI,EAAE,IAAI,EAAE,CAAC,EAAC,IAAI,EAAE,SAAS,EAAC,EAAG,EAAE;IAC3C,EAAE,IAAI,EAAE,iBAAU,EAAE;CACnB,CAAC;AA7DW,mBAAW,cA8DvB,CAAA","sourcesContent":["import {Injectable, PipeTransform, Pipe} from '@angular/core';\n\nimport {\n  isBlank,\n  isString,\n  isNumber,\n  isFunction,\n  RegExpWrapper,\n  StringWrapper\n} from '../../src/facade/lang';\n\nimport {InvalidPipeArgumentException} from './invalid_pipe_argument_exception';\nexport class ReplacePipe implements PipeTransform {\n/**\n * @param {?} value\n * @param {?} pattern\n * @param {?} replacement\n * @return {?}\n */\ntransform(value: any, pattern: string | RegExp, replacement: Function | string): any {\n    if (isBlank(value)) {\n      return value;\n    }\n\n    if (!this._supportedInput(value)) {\n      throw new InvalidPipeArgumentException(ReplacePipe, value);\n    }\n\n    var /** @type {?} */ input = value.toString();\n\n    if (!this._supportedPattern(pattern)) {\n      throw new InvalidPipeArgumentException(ReplacePipe, pattern);\n    }\n    if (!this._supportedReplacement(replacement)) {\n      throw new InvalidPipeArgumentException(ReplacePipe, replacement);\n    }\n    // template fails with literal RegExp e.g /pattern/igm\n    // var rgx = pattern instanceof RegExp ? pattern : RegExpWrapper.create(pattern);\n\n    if (isFunction(replacement)) {\n      var /** @type {?} */ rgxPattern = isString(pattern) ? RegExpWrapper.create( /** @type {?} */((<string>pattern))) : /** @type {?} */(( <RegExp>pattern));\n\n      return StringWrapper.replaceAllMapped(input, rgxPattern, /** @type {?} */(( <Function>replacement)));\n    }\n    if (pattern instanceof RegExp) {\n      // use the replaceAll variant\n      return StringWrapper.replaceAll(input, pattern, /** @type {?} */(( <string>replacement)));\n    }\n\n    return StringWrapper.replace(input, /** @type {?} */(( <string>pattern)), /** @type {?} */(( <string>replacement)));\n  }\n/**\n * @param {?} input\n * @return {?}\n */\nprivate _supportedInput(input: any): boolean { return isString(input) || isNumber(input); }\n/**\n * @param {?} pattern\n * @return {?}\n */\nprivate _supportedPattern(pattern: any): boolean {\n    return isString(pattern) || pattern instanceof RegExp;\n  }\n/**\n * @param {?} replacement\n * @return {?}\n */\nprivate _supportedReplacement(replacement: any): boolean {\n    return isString(replacement) || isFunction(replacement);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Pipe, args: [{name: 'replace'}, ] },\n{ type: Injectable },\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}