{"version":3,"file":"recognize.js","sourceRoot":"","sources":["../../../../../modules/@angular/router/src/recognize.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  RouteSegment,\n  UrlSegment,\n  Tree,\n  TreeNode,\n  rootNode,\n  UrlTree,\n  RouteTree,\n  equalUrlSegments\n} from './segments';\nimport {RoutesMetadata, RouteMetadata} from './metadata/metadata';\nimport {Type, isBlank, isPresent, stringify} from './facade/lang';\nimport {ListWrapper, StringMapWrapper} from './facade/collection';\nimport {PromiseWrapper} from './facade/promise';\nimport {BaseException, ComponentFactory} from '@angular/core';\nimport {ComponentResolver} from '@angular/core';\nimport {DEFAULT_OUTLET_NAME} from './constants';\nimport {reflector} from '@angular/core';\n/**\n * @param {?} componentResolver\n * @param {?} rootComponent\n * @param {?} url\n * @param {?} existingTree\n * @return {?}\n */\nexport function recognize(componentResolver: ComponentResolver, rootComponent: Type, url: UrlTree,\n                          existingTree: RouteTree): Promise<RouteTree> {\n  let /** @type {?} */ matched = new _MatchResult(rootComponent, [url.root], {}, rootNode(url).children, []);\n  return _constructSegment(componentResolver, matched, rootNode(existingTree))\n      .then(roots => new RouteTree(roots[0]));\n}\n/**\n * @param {?} componentResolver\n * @param {?} parentComponent\n * @param {?} url\n * @param {?} existingSegments\n * @return {?}\n */\nfunction _recognize(componentResolver: ComponentResolver, parentComponent: Type,\n                    url: TreeNode<UrlSegment>,\n                    existingSegments: TreeNode<RouteSegment>[]): Promise<TreeNode<RouteSegment>[]> {\n  let /** @type {?} */ metadata = _readMetadata(parentComponent);  // should read from the factory instead\n  if (isBlank(metadata)) {\n    throw new BaseException(\n        `Component '${stringify(parentComponent)}' does not have route configuration`);\n  }\n\n  let /** @type {?} */ match;\n  try {\n    match = _match(metadata, url);\n  } catch ( /** @type {?} */e) {\n    return PromiseWrapper.reject(e, null);\n  }\n\n  let /** @type {?} */ segmentsWithRightOutlet = existingSegments.filter(r => r.value.outlet == match.outlet);\n  let /** @type {?} */ segmentWithRightOutlet =\n      segmentsWithRightOutlet.length > 0 ? segmentsWithRightOutlet[0] : null;\n\n  let /** @type {?} */ main = _constructSegment(componentResolver, match, segmentWithRightOutlet);\n  let /** @type {?} */ aux = _recognizeMany(componentResolver, parentComponent, match.aux, existingSegments)\n                .then(_checkOutletNameUniqueness);\n  return PromiseWrapper.all([main, aux]).then(ListWrapper.flatten);\n}\n/**\n * @param {?} componentResolver\n * @param {?} parentComponent\n * @param {?} urls\n * @param {?} existingSegments\n * @return {?}\n */\nfunction _recognizeMany(\n    componentResolver: ComponentResolver, parentComponent: Type, urls: TreeNode<UrlSegment>[],\n    existingSegments: TreeNode<RouteSegment>[]): Promise<TreeNode<RouteSegment>[]> {\n  let /** @type {?} */ recognized =\n      urls.map(u => _recognize(componentResolver, parentComponent, u, existingSegments));\n  return PromiseWrapper.all(recognized).then(ListWrapper.flatten);\n}\n/**\n * @param {?} componentResolver\n * @param {?} matched\n * @param {?} existingSegment\n * @return {?}\n */\nfunction _constructSegment(\n    componentResolver: ComponentResolver, matched: _MatchResult,\n    existingSegment: TreeNode<RouteSegment>): Promise<TreeNode<RouteSegment>[]> {\n  return componentResolver.resolveComponent(matched.component)\n      .then(factory => {\n        let /** @type {?} */ segment = _createOrReuseSegment(matched, factory, existingSegment);\n        let /** @type {?} */ existingChildren = isPresent(existingSegment) ? existingSegment.children : [];\n\n        if (matched.leftOverUrl.length > 0) {\n          return _recognizeMany(componentResolver, factory.componentType, matched.leftOverUrl,\n                                existingChildren)\n              .then(children => [new TreeNode<RouteSegment>(segment, children)]);\n        } else {\n          return _recognizeLeftOvers(componentResolver, factory.componentType, existingChildren)\n              .then(children => [new TreeNode<RouteSegment>(segment, children)]);\n        }\n      });\n}\n/**\n * @param {?} matched\n * @param {?} factory\n * @param {?} segmentNode\n * @return {?}\n */\nfunction _createOrReuseSegment(matched: _MatchResult, factory: ComponentFactory<any>,\n                               segmentNode: TreeNode<RouteSegment>): RouteSegment {\n  let /** @type {?} */ segment = isPresent(segmentNode) ? segmentNode.value : null;\n\n  if (isPresent(segment) && equalUrlSegments(segment.urlSegments, matched.consumedUrlSegments) &&\n      StringMapWrapper.equals(segment.parameters, matched.parameters) &&\n      segment.outlet == matched.outlet && factory.componentType == segment.type) {\n    return segment;\n  } else {\n    return new RouteSegment(matched.consumedUrlSegments, matched.parameters, matched.outlet,\n                            factory.componentType, factory);\n  }\n}\n/**\n * @param {?} componentResolver\n * @param {?} parentComponent\n * @param {?} existingSegments\n * @return {?}\n */\nfunction _recognizeLeftOvers(\n    componentResolver: ComponentResolver, parentComponent: Type,\n    existingSegments: TreeNode<RouteSegment>[]): Promise<TreeNode<RouteSegment>[]> {\n  return componentResolver.resolveComponent(parentComponent)\n      .then(factory => {\n        let /** @type {?} */ metadata = _readMetadata(factory.componentType);\n        if (isBlank(metadata)) {\n          return [];\n        }\n\n        let /** @type {?} */ r = ( /** @type {?} */((<any[]>metadata.routes))).filter(r => r.path == \"\" || r.path == \"/\");\n        if (r.length === 0) {\n          return PromiseWrapper.resolve([]);\n        } else {\n          let /** @type {?} */ segmentsWithMatchingOutlet =\n              existingSegments.filter(r => r.value.outlet == DEFAULT_OUTLET_NAME);\n          let /** @type {?} */ segmentWithMatchingOutlet =\n              segmentsWithMatchingOutlet.length > 0 ? segmentsWithMatchingOutlet[0] : null;\n          let /** @type {?} */ existingChildren =\n              isPresent(segmentWithMatchingOutlet) ? segmentWithMatchingOutlet.children : [];\n\n          return _recognizeLeftOvers(componentResolver, r[0].component, existingChildren)\n              .then(children => {\n                return componentResolver.resolveComponent(r[0].component)\n                    .then(factory => {\n                      let /** @type {?} */ segment =\n                          _createOrReuseSegment(new _MatchResult(r[0].component, [], {}, [], []),\n                                                factory, segmentWithMatchingOutlet);\n                      return [new TreeNode<RouteSegment>(segment, children)];\n                    });\n              });\n        }\n      });\n}\n/**\n * @param {?} metadata\n * @param {?} url\n * @return {?}\n */\nfunction _match(metadata: RoutesMetadata, url: TreeNode<UrlSegment>): _MatchResult {\n  for (let /** @type {?} */ r of metadata.routes) {\n    let /** @type {?} */ matchingResult = _matchWithParts(r, url);\n    if (isPresent(matchingResult)) {\n      return matchingResult;\n    }\n  }\n  let /** @type {?} */ availableRoutes = metadata.routes.map(r => `'${r.path}'`).join(\", \");\n  throw new BaseException(\n      `Cannot match any routes. Current segment: '${url.value}'. Available routes: [${availableRoutes}].`);\n}\n/**\n * @param {?} route\n * @param {?} url\n * @return {?}\n */\nfunction _matchWithParts(route: RouteMetadata, url: TreeNode<UrlSegment>): _MatchResult {\n  let /** @type {?} */ path = route.path.startsWith(\"/\") ? route.path.substring(1) : route.path;\n\n  if (path == \"*\") {\n    return new _MatchResult(route.component, [], null, [], []);\n  }\n\n  let /** @type {?} */ parts = path.split(\"/\");\n  let /** @type {?} */ positionalParams = {};\n  let /** @type {?} */ consumedUrlSegments = [];\n\n  let /** @type {?} */ lastParent: TreeNode<UrlSegment> = null;\n  let /** @type {?} */ lastSegment: TreeNode<UrlSegment> = null;\n\n  let /** @type {?} */ current = url;\n  for (let /** @type {?} */ i = 0; i < parts.length; ++i) {\n    if (isBlank(current)) return null;\n\n    let /** @type {?} */ p = parts[i];\n    let /** @type {?} */ isLastSegment = i === parts.length - 1;\n    let /** @type {?} */ isLastParent = i === parts.length - 2;\n    let /** @type {?} */ isPosParam = p.startsWith(\":\");\n\n    if (!isPosParam && p != current.value.segment) return null;\n    if (isLastSegment) {\n      lastSegment = current;\n    }\n    if (isLastParent) {\n      lastParent = current;\n    }\n\n    if (isPosParam) {\n      positionalParams[p.substring(1)] = current.value.segment;\n    }\n\n    consumedUrlSegments.push(current.value);\n\n    current = ListWrapper.first(current.children);\n  }\n\n  let /** @type {?} */ p = lastSegment.value.parameters;\n  let /** @type {?} */ parameters = /** @type {?} */(( <{[key: string]: string}>StringMapWrapper.merge(p, positionalParams)));\n  let /** @type {?} */ axuUrlSubtrees = isPresent(lastParent) ? lastParent.children.slice(1) : [];\n\n  return new _MatchResult(route.component, consumedUrlSegments, parameters, lastSegment.children,\n                          axuUrlSubtrees);\n}\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction _checkOutletNameUniqueness(nodes: TreeNode<RouteSegment>[]): TreeNode<RouteSegment>[] {\n  let /** @type {?} */ names = {};\n  nodes.forEach(n => {\n    let /** @type {?} */ segmentWithSameOutletName = names[n.value.outlet];\n    if (isPresent(segmentWithSameOutletName)) {\n      let /** @type {?} */ p = segmentWithSameOutletName.stringifiedUrlSegments;\n      let /** @type {?} */ c = n.value.stringifiedUrlSegments;\n      throw new BaseException(`Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    names[n.value.outlet] = n.value;\n  });\n  return nodes;\n}\n\nclass _MatchResult {\n/**\n * @param {?} component\n * @param {?} consumedUrlSegments\n * @param {?} parameters\n * @param {?} leftOverUrl\n * @param {?} aux\n */\nconstructor(public component: Type | string,\npublic consumedUrlSegments: UrlSegment[],\npublic parameters: {[key: string]: string},\npublic leftOverUrl: TreeNode<UrlSegment>[],\npublic aux: TreeNode<UrlSegment>[]) {}\n\n  get outlet(): string {\n    return this.consumedUrlSegments.length === 0 || isBlank(this.consumedUrlSegments[0].outlet) ?\n               DEFAULT_OUTLET_NAME :\n               this.consumedUrlSegments[0].outlet;\n  }\n\n  static _tsickle_typeAnnotationsHelper() {\n /** @type {?} */\n_MatchResult.prototype.component;\n /** @type {?} */\n_MatchResult.prototype.consumedUrlSegments;\n /** @type {?} */\n_MatchResult.prototype.parameters;\n /** @type {?} */\n_MatchResult.prototype.leftOverUrl;\n /** @type {?} */\n_MatchResult.prototype.aux;\n  }\n\n}\n/**\n * @param {?} componentType\n * @return {?}\n */\nfunction _readMetadata(componentType: Type) {\n  let /** @type {?} */ metadata = reflector.annotations(componentType).filter(f => f instanceof RoutesMetadata);\n  return ListWrapper.first(metadata);\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}