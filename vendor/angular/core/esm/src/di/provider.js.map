{"version":3,"file":"provider.js","sourceRoot":"","sources":["../../../../../../modules/@angular/core/src/di/provider.ts"],"names":[],"mappings":"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","sourcesContent":["import {normalizeBool, Type, isType, isBlank, isFunction, stringify} from '../../src/facade/lang';\nimport {BaseException} from '../../src/facade/exceptions';\n\n/**\n * Describes how the {@link Injector} should instantiate a given token.\n *\n * See {@link provide}.\n *\n * ### Example ([live demo](http://plnkr.co/edit/GNAyj6K6PfYg2NBzgwZ5?p%3Dpreview&p=preview))\n *\n * ```javascript\n * var injector = Injector.resolveAndCreate([\n *   new Provider(\"message\", { useValue: 'Hello' })\n * ]);\n *\n * expect(injector.get(\"message\")).toEqual('Hello');\n * ```\n * @ts2dart_const\n */\nexport class Provider {\n  /**\n   * Token used when retrieving this provider. Usually, it is a type {@link Type}.\n   */\n  token;\n\n  /**\n   * Binds a DI token to an implementation class.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/RSTG86qgmoxCyj9SWPwY?p=preview))\n   *\n   * Because `useExisting` and `useClass` are often confused, the example contains\n   * both use cases for easy comparison.\n   *\n   * ```typescript\n   * class Vehicle {}\n   *\n   * class Car extends Vehicle {}\n   *\n   * var injectorClass = Injector.resolveAndCreate([\n   *   Car,\n   *   {provide: Vehicle,  useClass: Car }\n   * ]);\n   * var injectorAlias = Injector.resolveAndCreate([\n   *   Car,\n   *   {provide: Vehicle,  useExisting: Car }\n   * ]);\n   *\n   * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n   * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n   *\n   * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n   * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n   * ```\n   */\n  useClass: Type;\n\n  /**\n   * Binds a DI token to a value.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/UFVsMVQIDe7l4waWziES?p=preview))\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   new Provider(\"message\", { useValue: 'Hello' })\n   * ]);\n   *\n   * expect(injector.get(\"message\")).toEqual('Hello');\n   * ```\n   */\n  useValue;\n\n  /**\n   * Binds a DI token to an existing token.\n   *\n   * {@link Injector} returns the same instance as if the provided token was used.\n   * This is in contrast to `useClass` where a separate instance of `useClass` is returned.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/QsatsOJJ6P8T2fMe9gr8?p=preview))\n   *\n   * Because `useExisting` and `useClass` are often confused the example contains\n   * both use cases for easy comparison.\n   *\n   * ```typescript\n   * class Vehicle {}\n   *\n   * class Car extends Vehicle {}\n   *\n   * var injectorAlias = Injector.resolveAndCreate([\n   *   Car,\n   *   {provide: Vehicle,  useExisting: Car }\n   * ]);\n   * var injectorClass = Injector.resolveAndCreate([\n   *   Car,\n   *   {provide: Vehicle,  useClass: Car }\n   * ]);\n   *\n   * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n   * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n   *\n   * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n   * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n   * ```\n   */\n  useExisting;\n\n  /**\n   * Binds a DI token to a function which computes the value.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/Scoxy0pJNqKGAPZY1VVC?p=preview))\n   *\n   * ```typescript\n   * var injector = Injector.resolveAndCreate([\n   *   {provide: Number,  useFactory: () => { return 1+2; }},\n   *   new Provider(String, { useFactory: (value) => { return \"Value: \" + value; },\n   *                       deps: [Number] })\n   * ]);\n   *\n   * expect(injector.get(Number)).toEqual(3);\n   * expect(injector.get(String)).toEqual('Value: 3');\n   * ```\n   *\n   * Used in conjunction with dependencies.\n   */\n  useFactory: Function;\n\n  /**\n   * Specifies a set of dependencies\n   * (as `token`s) which should be injected into the factory function.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/Scoxy0pJNqKGAPZY1VVC?p=preview))\n   *\n   * ```typescript\n   * var injector = Injector.resolveAndCreate([\n   *   {provide: Number,  useFactory: () => { return 1+2; }},\n   *   new Provider(String, { useFactory: (value) => { return \"Value: \" + value; },\n   *                       deps: [Number] })\n   * ]);\n   *\n   * expect(injector.get(Number)).toEqual(3);\n   * expect(injector.get(String)).toEqual('Value: 3');\n   * ```\n   *\n   * Used in conjunction with `useFactory`.\n   */\n  dependencies: Object[];\n\n  /** @internal */\n  _multi: boolean;\n/**\n * @param {?} token\n * @param {?} __1\n */\nconstructor(token, {useClass, useValue, useExisting, useFactory, deps, multi}: {\n    useClass?: Type,\n    useValue?: any,\n    useExisting?: any,\n    useFactory?: Function,\n    deps?: Object[],\n    multi?: boolean\n  }) {\n    this.token = token;\n    this.useClass = useClass;\n    this.useValue = useValue;\n    this.useExisting = useExisting;\n    this.useFactory = useFactory;\n    this.dependencies = deps;\n    this._multi = multi;\n  }\n\n  // TODO: Provide a full working example after alpha38 is released.\n  /**\n   * Creates multiple providers matching the same token (a multi-provider).\n   *\n   * Multi-providers are used for creating pluggable service, where the system comes\n   * with some default providers, and the user can register additional providers.\n   * The combination of the default providers and the additional providers will be\n   * used to drive the behavior of the system.\n   *\n   * ### Example\n   *\n   * ```typescript\n   * var injector = Injector.resolveAndCreate([\n   *   new Provider(\"Strings\", { useValue: \"String1\", multi: true}),\n   *   new Provider(\"Strings\", { useValue: \"String2\", multi: true})\n   * ]);\n   *\n   * expect(injector.get(\"Strings\")).toEqual([\"String1\", \"String2\"]);\n   * ```\n   *\n   * Multi-providers and regular providers cannot be mixed. The following\n   * will throw an exception:\n   *\n   * ```typescript\n   * var injector = Injector.resolveAndCreate([\n   *   new Provider(\"Strings\", { useValue: \"String1\", multi: true }),\n   *   new Provider(\"Strings\", { useValue: \"String2\"})\n   * ]);\n   * ```\n   */\n  get multi(): boolean { return normalizeBool(this._multi); }\n\n  static _tsickle_typeAnnotationsHelper() {\n /** Token used when retrieving this provider. Usually, it is a type {@link Type}.\n @type {?} */\nProvider.prototype.token;\n /** Binds a DI token to an implementation class. * ### Example ([live demo](http://plnkr.co/edit/RSTG86qgmoxCyj9SWPwY?p=preview)) * Because `useExisting` and `useClass` are often confused, the example contains both use cases for easy comparison. * ```typescript class Vehicle {} * class Car extends Vehicle {} * var injectorClass = Injector.resolveAndCreate([ Car, {provide: Vehicle,  useClass: Car } ]); var injectorAlias = Injector.resolveAndCreate([ Car, {provide: Vehicle,  useExisting: Car } ]); * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car)); expect(injectorClass.get(Vehicle) instanceof Car).toBe(true); * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car)); expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true); ```\n @type {?} */\nProvider.prototype.useClass;\n /** Binds a DI token to a value. * ### Example ([live demo](http://plnkr.co/edit/UFVsMVQIDe7l4waWziES?p=preview)) * ```javascript var injector = Injector.resolveAndCreate([ new Provider(\"message\", { useValue: 'Hello' }) ]); * expect(injector.get(\"message\")).toEqual('Hello'); ```\n @type {?} */\nProvider.prototype.useValue;\n /** Binds a DI token to an existing token. * {@link Injector} returns the same instance as if the provided token was used. This is in contrast to `useClass` where a separate instance of `useClass` is returned. * ### Example ([live demo](http://plnkr.co/edit/QsatsOJJ6P8T2fMe9gr8?p=preview)) * Because `useExisting` and `useClass` are often confused the example contains both use cases for easy comparison. * ```typescript class Vehicle {} * class Car extends Vehicle {} * var injectorAlias = Injector.resolveAndCreate([ Car, {provide: Vehicle,  useExisting: Car } ]); var injectorClass = Injector.resolveAndCreate([ Car, {provide: Vehicle,  useClass: Car } ]); * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car)); expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true); * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car)); expect(injectorClass.get(Vehicle) instanceof Car).toBe(true); ```\n @type {?} */\nProvider.prototype.useExisting;\n /** Binds a DI token to a function which computes the value. * ### Example ([live demo](http://plnkr.co/edit/Scoxy0pJNqKGAPZY1VVC?p=preview)) * ```typescript var injector = Injector.resolveAndCreate([ {provide: Number,  useFactory: () => { return 1+2; }}, new Provider(String, { useFactory: (value) => { return \"Value: \" + value; }, deps: [Number] }) ]); * expect(injector.get(Number)).toEqual(3); expect(injector.get(String)).toEqual('Value: 3'); ``` * Used in conjunction with dependencies.\n @type {?} */\nProvider.prototype.useFactory;\n /** Specifies a set of dependencies (as `token`s) which should be injected into the factory function. * ### Example ([live demo](http://plnkr.co/edit/Scoxy0pJNqKGAPZY1VVC?p=preview)) * ```typescript var injector = Injector.resolveAndCreate([ {provide: Number,  useFactory: () => { return 1+2; }}, new Provider(String, { useFactory: (value) => { return \"Value: \" + value; }, deps: [Number] }) ]); * expect(injector.get(Number)).toEqual(3); expect(injector.get(String)).toEqual('Value: 3'); ``` * Used in conjunction with `useFactory`.\n @type {?} */\nProvider.prototype.dependencies;\n /** @internal\n @type {?} */\nProvider.prototype._multi;\n  }\n\n}\n\n/**\n * See {@link Provider} instead.\n *\n * @deprecated\n * @ts2dart_const\n */\nexport class Binding extends Provider {\n/**\n * @param {?} token\n * @param {?} __1\n */\nconstructor(token, {toClass, toValue, toAlias, toFactory, deps, multi}: {\n    toClass?: Type,\n    toValue?: any,\n    toAlias?: any,\n    toFactory: Function, deps?: Object[], multi?: boolean\n  }) {\n    super(token, {\n      useClass: toClass,\n      useValue: toValue,\n      useExisting: toAlias,\n      useFactory: toFactory,\n      deps: deps,\n      multi: multi\n    });\n  }\n\n  /**\n   * @deprecated\n   */\n  get toClass() { return this.useClass; }\n\n  /**\n   * @deprecated\n   */\n  get toAlias() { return this.useExisting; }\n\n  /**\n   * @deprecated\n   */\n  get toFactory() { return this.useFactory; }\n\n  /**\n   * @deprecated\n   */\n  get toValue() { return this.useValue; }\n}\n/**\n *  Creates a {@link Provider}. * To construct a {@link Provider}, bind a `token` to either a class, a value, a factory function, or to an existing `token`. See {@link ProviderBuilder} for more details. * The `token` is most commonly a class or {@link OpaqueToken-class.html}. *\n * @deprecated\n * @param {?} token\n * @return {?}\n */\nexport function bind(token): ProviderBuilder {\n  return new ProviderBuilder(token);\n}\n\n/**\n * Helper class for the {@link bind} function.\n */\nexport class ProviderBuilder {\n/**\n * @param {?} token\n */\nconstructor(public token) {}\n/**\n *  Binds a DI token to a class. * ### Example ([live demo](http://plnkr.co/edit/ZpBCSYqv6e2ud5KXLdxQ?p=preview)) * Because `toAlias` and `toClass` are often confused, the example contains both use cases for easy comparison. * ```typescript class Vehicle {} * class Car extends Vehicle {} * var injectorClass = Injector.resolveAndCreate([ Car, provide(Vehicle, {useClass: Car}) ]); var injectorAlias = Injector.resolveAndCreate([ Car, provide(Vehicle, {useExisting: Car}) ]); * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car)); expect(injectorClass.get(Vehicle) instanceof Car).toBe(true); * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car)); expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true); ```\n * @param {?} type\n * @return {?}\n */\ntoClass(type: Type): Provider {\n    if (!isType(type)) {\n      throw new BaseException(\n          `Trying to create a class provider but \"${stringify(type)}\" is not a class!`);\n    }\n    return new Provider(this.token, {useClass: type});\n  }\n/**\n *  Binds a DI token to a value. * ### Example ([live demo](http://plnkr.co/edit/G024PFHmDL0cJFgfZK8O?p=preview)) * ```typescript var injector = Injector.resolveAndCreate([ provide('message', {useValue: 'Hello'}) ]); * expect(injector.get('message')).toEqual('Hello'); ```\n * @param {?} value\n * @return {?}\n */\ntoValue(value: any): Provider { return new Provider(this.token, {useValue: value}); }\n/**\n *  Binds a DI token to an existing token. * Angular will return the same instance as if the provided token was used. (This is in contrast to `useClass` where a separate instance of `useClass` will be returned.) * ### Example ([live demo](http://plnkr.co/edit/uBaoF2pN5cfc5AfZapNw?p=preview)) * Because `toAlias` and `toClass` are often confused, the example contains both use cases for easy comparison. * ```typescript class Vehicle {} * class Car extends Vehicle {} * var injectorAlias = Injector.resolveAndCreate([ Car, provide(Vehicle, {useExisting: Car}) ]); var injectorClass = Injector.resolveAndCreate([ Car, provide(Vehicle, {useClass: Car}) ]); * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car)); expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true); * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car)); expect(injectorClass.get(Vehicle) instanceof Car).toBe(true); ```\n * @param {?} aliasToken\n * @return {?}\n */\ntoAlias(aliasToken: /*Type*/ any): Provider {\n    if (isBlank(aliasToken)) {\n      throw new BaseException(`Can not alias ${stringify(this.token)} to a blank value!`);\n    }\n    return new Provider(this.token, {useExisting: aliasToken});\n  }\n/**\n *  Binds a DI token to a function which computes the value. * ### Example ([live demo](http://plnkr.co/edit/OejNIfTT3zb1iBxaIYOb?p=preview)) * ```typescript var injector = Injector.resolveAndCreate([ provide(Number, {useFactory: () => { return 1+2; }}), provide(String, {useFactory: (v) => { return \"Value: \" + v; }, deps: [Number]}) ]); * expect(injector.get(Number)).toEqual(3); expect(injector.get(String)).toEqual('Value: 3'); ```\n * @param {?} factory\n * @param {?=} dependencies\n * @return {?}\n */\ntoFactory(factory: Function, dependencies?: any[]): Provider {\n    if (!isFunction(factory)) {\n      throw new BaseException(\n          `Trying to create a factory provider but \"${stringify(factory)}\" is not a function!`);\n    }\n    return new Provider(this.token, {useFactory: factory, deps: dependencies});\n  }\n\n  static _tsickle_typeAnnotationsHelper() {\n /** @type {?} */\nProviderBuilder.prototype.token;\n  }\n\n}\n/**\n *  Creates a {@link Provider}. * See {@link Provider} for more details. * <!-- TODO: improve the docs -->\n * @param {?} token\n * @param {?} __1\n * @return {?}\n */\nexport function provide(token, {useClass, useValue, useExisting, useFactory, deps, multi}: {\n  useClass?: Type,\n  useValue?: any,\n  useExisting?: any,\n  useFactory?: Function,\n  deps?: Object[],\n  multi?: boolean\n}): Provider {\n  return new Provider(token, {\n    useClass: useClass,\n    useValue: useValue,\n    useExisting: useExisting,\n    useFactory: useFactory,\n    deps: deps,\n    multi: multi\n  });\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}