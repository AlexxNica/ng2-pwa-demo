{"version":3,"file":"ng_zone.js","sourceRoot":"","sources":["../../../../../../modules/@angular/core/src/zone/ng_zone.ts"],"names":[],"mappings":"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","sourcesContent":["import {EventEmitter} from '../../src/facade/async';\nimport {NgZoneImpl, NgZoneError} from './ng_zone_impl';\nimport {BaseException} from '../../src/facade/exceptions';\nexport {NgZoneError} from './ng_zone_impl';\n\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))\n * ```\n * import {Component, View, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo'.\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n *   directives: [NgIf]\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *       // reenter the Angular zone and display done\n *       this._ngZone.run(() => {console.log('Outside Done!') });\n *     }}));\n *   }\n *\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n */\nexport class NgZone {\n/**\n * @return {?}\n */\nstatic isInAngularZone(): boolean { return NgZoneImpl.isInAngularZone(); }\n/**\n * @return {?}\n */\nstatic assertInAngularZone(): void {\n    if (!NgZoneImpl.isInAngularZone()) {\n      throw new BaseException('Expected to be in Angular Zone, but it is not!');\n    }\n  }\n/**\n * @return {?}\n */\nstatic assertNotInAngularZone(): void {\n    if (NgZoneImpl.isInAngularZone()) {\n      throw new BaseException('Expected to not be in Angular Zone, but it is!');\n    }\n  }\nprivate _zoneImpl: NgZoneImpl;\nprivate _hasPendingMicrotasks: boolean = false;\nprivate _hasPendingMacrotasks: boolean = false;\nprivate _isStable = true;\nprivate _nesting = 0;\nprivate _onUnstable: EventEmitter<any> = new EventEmitter(false);\nprivate _onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\nprivate _onStable: EventEmitter<any> = new EventEmitter(false);\nprivate _onErrorEvents: EventEmitter<any> = new EventEmitter(false);\n/**\n * @param {?} __0\n */\nconstructor({enableLongStackTrace = false}) {\n    this._zoneImpl = new NgZoneImpl({\n      trace: enableLongStackTrace,\n      onEnter: () => {\n        // console.log('ZONE.enter', this._nesting, this._isStable);\n        this._nesting++;\n        if (this._isStable) {\n          this._isStable = false;\n          this._onUnstable.emit(null);\n        }\n      },\n      onLeave: () => {\n        this._nesting--;\n        // console.log('ZONE.leave', this._nesting, this._isStable);\n        this._checkStable();\n      },\n      setMicrotask: (hasMicrotasks: boolean) => {\n        this._hasPendingMicrotasks = hasMicrotasks;\n        this._checkStable();\n      },\n      setMacrotask: (hasMacrotasks: boolean) => { this._hasPendingMacrotasks = hasMacrotasks; },\n      onError: (error: NgZoneError) => this._onErrorEvents.emit(error)\n    });\n  }\n/**\n * @return {?}\n */\nprivate _checkStable() {\n    if (this._nesting == 0) {\n      if (!this._hasPendingMicrotasks && !this._isStable) {\n        try {\n          // console.log('ZONE.microtaskEmpty');\n          this._nesting++;\n          this._onMicrotaskEmpty.emit(null);\n        } finally {\n          this._nesting--;\n          if (!this._hasPendingMicrotasks) {\n            try {\n              // console.log('ZONE.stable', this._nesting, this._isStable);\n              this.runOutsideAngular(() => this._onStable.emit(null));\n            } finally {\n              this._isStable = true;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  get onUnstable(): EventEmitter<any> { return this._onUnstable; }\n\n  /**\n   * Notifies when there is no more microtasks enqueue in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  get onMicrotaskEmpty(): EventEmitter<any> { return this._onMicrotaskEmpty; }\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  get onStable(): EventEmitter<any> { return this._onStable; }\n\n  /**\n   * Notify that an error has been delivered.\n   */\n  get onError(): EventEmitter<any> { return this._onErrorEvents; }\n\n  /**\n   * Whether there are any outstanding microtasks.\n   */\n  get hasPendingMicrotasks(): boolean { return this._hasPendingMicrotasks; }\n\n  /**\n   * Whether there are any outstanding microtasks.\n   */\n  get hasPendingMacrotasks(): boolean { return this._hasPendingMacrotasks; }\n/**\n *  Executes the `fn` function synchronously within the Angular zone and returns value returned by the function. * Running functions via `run` allows you to reenter Angular zone from a task that was executed outside of the Angular zone (typically started via {@link #runOutsideAngular}). * Any future tasks or microtasks scheduled from within this function will continue executing from within the Angular zone. * If a synchronous error happens it will be rethrown and not reported via `onError`.\n * @param {?} fn\n * @return {?}\n */\nrun(fn: () => any): any { return this._zoneImpl.runInner(fn); }\n/**\n *  Same as #run, except that synchronous errors are caught and forwarded via `onError` and not rethrown.\n * @param {?} fn\n * @return {?}\n */\nrunGuarded(fn: () => any): any { return this._zoneImpl.runInnerGuarded(fn); }\n/**\n *  Executes the `fn` function synchronously in Angular's parent zone and returns value returned by the function. * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that doesn't trigger Angular change-detection or is subject to Angular's error handling. * Any future tasks or microtasks scheduled from within this function will continue executing from outside of the Angular zone. * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n * @param {?} fn\n * @return {?}\n */\nrunOutsideAngular(fn: () => any): any { return this._zoneImpl.runOuter(fn); }\n\n  static _tsickle_typeAnnotationsHelper() {\n /** @type {?} */\nNgZone.prototype._zoneImpl;\n /** @type {?} */\nNgZone.prototype._hasPendingMicrotasks;\n /** @type {?} */\nNgZone.prototype._hasPendingMacrotasks;\n /** @internal\n @type {?} */\nNgZone.prototype._isStable;\n /** @internal\n @type {?} */\nNgZone.prototype._nesting;\n /** @internal\n @type {?} */\nNgZone.prototype._onUnstable;\n /** @internal\n @type {?} */\nNgZone.prototype._onMicrotaskEmpty;\n /** @internal\n @type {?} */\nNgZone.prototype._onStable;\n /** @internal\n @type {?} */\nNgZone.prototype._onErrorEvents;\n  }\n\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}