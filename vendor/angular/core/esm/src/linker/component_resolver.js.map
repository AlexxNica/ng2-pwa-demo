{"version":3,"file":"component_resolver.js","sourceRoot":"","sources":["../../../../../../modules/@angular/core/src/linker/component_resolver.ts"],"names":[],"mappings":";AAAA,uBAAiD,uBAAuB,CAAC,CAAA;AACzE,6BAA4B,6BAA6B,CAAC,CAAA;AAC1D,wBAA6B,wBAAwB,CAAC,CAAA;AACtD,6BAAwB,0BAA0B,CAAC,CAAA;AACnD,oCAA+B,qBAAqB,CAAC,CAAA;AACrD,6BAAyB,kBAAkB,CAAC,CAAA;AAE5C;;;GAGG;AACH;AAGA,CAAC;AAHqB,yBAAiB,oBAGtC,CAAA;AACD;;;GAGG;AACH,6BAA6B,IAAS;IACpC,MAAM,CAAC,IAAI,YAAY,oCAAgB,CAAC;AAC1C,CAAC;AACD,yCAAgD,iBAAiB;IACjE;;;OAGG;IACH,gBAAgB,CAAC,SAAsB;QACnC,EAAE,CAAC,CAAC,eAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YACxB,MAAM,CAAC,sBAAc,CAAC,MAAM,CAAC,IAAI,0BAAa,CAAC,mCAAmC,SAAS,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;QAC1G,CAAC;QAED,IAAI,gBAAgB,CAAC,SAAS,GAAG,sBAAS,CAAC,WAAW,CAAE,gBAAgB,CAAA,CAAQ,SAAU,CAAC,CAAC,CAAC;QAC7F,IAAI,gBAAgB,CAAC,gBAAgB,GAAG,SAAS,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;QAE5E,EAAE,CAAC,CAAC,cAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;YAC9B,MAAM,IAAI,0BAAa,CAAC,4BAA4B,gBAAS,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;QACpF,CAAC;QACD,MAAM,CAAC,sBAAc,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;IAClD,CAAC;IACH;;OAEG;IACH,UAAU,KAAI,CAAC;AAIf,CAAC;AAHM,qCAAU,GAA0B;IAC3C,EAAE,IAAI,EAAE,uBAAU,EAAE;CACnB,CAAC;AAxBW,kCAA0B,6BAyBtC,CAAA","sourcesContent":["import {Type, isBlank, isString, stringify} from '../../src/facade/lang';\nimport {BaseException} from '../../src/facade/exceptions';\nimport {PromiseWrapper} from '../../src/facade/async';\nimport {reflector} from '../reflection/reflection';\nimport {ComponentFactory} from './component_factory';\nimport {Injectable} from '../di/decorators';\n\n/**\n * Low-level service for loading {@link ComponentFactory}s, which\n * can later be used to create and render a Component instance.\n */\nexport abstract class ComponentResolver {\n  abstract resolveComponent(component: Type|string): Promise<ComponentFactory<any>>;\n  abstract clearCache();\n}\n/**\n * @param {?} type\n * @return {?}\n */\nfunction _isComponentFactory(type: any): boolean {\n  return type instanceof ComponentFactory;\n}\nexport class ReflectorComponentResolver extends ComponentResolver {\n/**\n * @param {?} component\n * @return {?}\n */\nresolveComponent(component: Type|string): Promise<ComponentFactory<any>> {\n    if (isString(component)) {\n      return PromiseWrapper.reject(new BaseException(`Cannot resolve component using '${component}'.`), null);\n    }\n\n    var /** @type {?} */ metadatas = reflector.annotations( /** @type {?} */((<Type>component)));\n    var /** @type {?} */ componentFactory = metadatas.find(_isComponentFactory);\n\n    if (isBlank(componentFactory)) {\n      throw new BaseException(`No precompiled component ${stringify(component)} found`);\n    }\n    return PromiseWrapper.resolve(componentFactory);\n  }\n/**\n * @return {?}\n */\nclearCache() {}\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}