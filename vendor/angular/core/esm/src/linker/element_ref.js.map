{"version":3,"file":"element_ref.js","sourceRoot":"","sources":["../../../../../../modules/@angular/core/src/linker/element_ref.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;AACH,2EAA2E;AAC3E,2FAA2F;AAC3F,6CAA6C;AAC7C;IAEA;;OAEG;IACH,YAAY,aAAkB;QAAI,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;IAAC,CAAC;IAErE,OAAO,8BAA8B;QACtC;oBACY;QACb,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC;IACjC,CAAC;AAEH,CAAC;AAbY,kBAAU,aAatB,CAAA","sourcesContent":["/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nexport class ElementRef {\npublic nativeElement: any;\n/**\n * @param {?} nativeElement\n */\nconstructor(nativeElement: any) { this.nativeElement = nativeElement; }\n\n  static _tsickle_typeAnnotationsHelper() {\n /** The underlying native element or `null` if direct access to native elements is not supported (e.g. when the application runs in a web worker). * <div class=\"callout is-critical\"> <header>Use with caution</header> <p> Use this API as the last resort when direct access to DOM is needed. Use templating and data-binding provided by Angular instead. Alternatively you take a look at {@link Renderer} which provides API that can safely be used even when direct access to native elements is not supported. </p> <p> Relying on direct DOM access creates tight coupling between your application and rendering layers which will make it impossible to separate the two and deploy your application into a web worker. </p> </div>\n @type {?} */\nElementRef.prototype.nativeElement;\n  }\n\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}