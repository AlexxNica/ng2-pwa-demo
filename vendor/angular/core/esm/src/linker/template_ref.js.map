{"version":3,"file":"template_ref.js","sourceRoot":"","sources":["../../../../../../modules/@angular/core/src/linker/template_ref.ts"],"names":[],"mappings":";AAAA,uBAAsB,gBAAgB,CAAC,CAAA;AAMvC,MAAM,gBAAgB,CAAC,aAAa,GAAsB,IAAI,MAAM,EAAE,CAAC;AAEvE;;;;;;;;;;;GAWG;AACH;IACE;;;;;;;;;;OAUG;IACH,wCAAwC;IACxC,IAAI,UAAU,KAAiB,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAG/C,CAAC;AAhBqB,mBAAW,cAgBhC,CAAA;AAED,2BAAqC,WAAW;IAChD;;;OAGG;IACH,YAAoB,WAAuB,EACnC,YAAsB;QAAI,OAAO,CAAC;QADtB,gBAAW,GAAX,WAAW,CAAY;QACnC,iBAAY,GAAZ,YAAY,CAAU;IAAa,CAAC;IAC5C;;;OAGG;IACH,kBAAkB,CAAC,OAAU;QACzB,IAAI,gBAAgB,CAAC,IAAI,GAAe,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,SAAS,EACtD,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;QAC5F,EAAE,CAAC,CAAC,cAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACrB,OAAO,GAAmB,CAAQ,aAAc,CAAC,CAAC;QACpD,CAAC;QACD,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QACjC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC;IAClB,CAAC;IAED,IAAI,UAAU,KAAiB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC;IAEpE,OAAO,8BAA8B;QACtC,gBAAgB;QACjB,YAAY,CAAC,SAAS,CAAC,WAAW,CAAC;QAClC,gBAAgB;QACjB,YAAY,CAAC,SAAS,CAAC,YAAY,CAAC;IAClC,CAAC;AAEH,CAAC;AA9BY,oBAAY,eA8BxB,CAAA","sourcesContent":["import {isBlank} from '../facade/lang';\nimport {ElementRef} from './element_ref';\nimport {AppElement} from './element';\nimport {AppView} from './view';\nimport {EmbeddedViewRef} from './view_ref';\n\nconst /** @type {?} */ EMPTY_CONTEXT = /*@ts2dart_const*/ new Object();\n\n/**\n * Represents an Embedded Template that can be used to instantiate Embedded Views.\n *\n * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or\n * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the\n * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the\n * `TemplateRef` from a Component or a Directive via {@link Query}.\n *\n * To instantiate Embedded Views based on a Template, use\n * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the\n * View Container.\n */\nexport abstract class TemplateRef<C> {\n  /**\n   * The location in the View where the Embedded View logically belongs to.\n   *\n   * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`\n   * inherit from the contexts of this location.\n   *\n   * Typically new Embedded Views are attached to the View Container of this location, but in\n   * advanced use-cases, the View can be attached to a different container while keeping the\n   * data-binding and injection context from the original location.\n   *\n   */\n  // TODO(i): rename to anchor or location\n  get elementRef(): ElementRef { return null; }\n\n  abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;\n}\n\nexport class TemplateRef_<C> extends TemplateRef<C> {\n/**\n * @param {?} _appElement\n * @param {?} _viewFactory\n */\nconstructor(private _appElement: AppElement,\nprivate _viewFactory: Function) { super(); }\n/**\n * @param {?} context\n * @return {?}\n */\ncreateEmbeddedView(context: C): EmbeddedViewRef<C> {\n    var /** @type {?} */ view: AppView<C> = this._viewFactory(this._appElement.parentView.viewUtils,\n                                             this._appElement.parentInjector, this._appElement);\n    if (isBlank(context)) {\n      context = /** @type {?} */(( <any>EMPTY_CONTEXT));\n    }\n    view.create(context, null, null);\n    return view.ref;\n  }\n\n  get elementRef(): ElementRef { return this._appElement.elementRef; }\n\n  static _tsickle_typeAnnotationsHelper() {\n /** @type {?} */\nTemplateRef_.prototype._appElement;\n /** @type {?} */\nTemplateRef_.prototype._viewFactory;\n  }\n\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}