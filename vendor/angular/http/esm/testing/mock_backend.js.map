{"version":3,"file":"mock_backend.js","sourceRoot":"","sources":["../../../../../modules/@angular/http/testing/mock_backend.ts"],"names":[],"mappings":"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","sourcesContent":["import {Injectable} from '@angular/core';\nimport {Request} from '../src/static_request';\nimport {Response} from '../src/static_response';\nimport {ReadyState} from '../src/enums';\nimport {Connection, ConnectionBackend} from '../src/interfaces';\nimport {isPresent} from '../src/facade/lang';\nimport {BaseException} from '../src/facade/exceptions';\nimport {Subject} from 'rxjs/Subject';\nimport {ReplaySubject} from 'rxjs/ReplaySubject';\nimport {take} from 'rxjs/operator/take';\n\n/**\n *\n * Mock Connection to represent a {@link Connection} for tests.\n *\n **/\nexport class MockConnection implements Connection {\n  // TODO Name `readyState` should change to be more generic, and states could be made to be more\n  // descriptive than XHR states.\n  /**\n   * Describes the state of the connection, based on `XMLHttpRequest.readyState`, but with\n   * additional states. For example, state 5 indicates an aborted connection.\n   */\n  readyState: ReadyState;\n\n  /**\n   * {@link Request} instance used to create the connection.\n   */\n  request: Request;\n\n  /**\n   * {@link EventEmitter} of {@link Response}. Can be subscribed to in order to be notified when a\n   * response is available.\n   */\n  response: ReplaySubject<Response>;\n/**\n * @param {?} req\n */\nconstructor(req: Request) {\n    this.response = <any>take.call(new ReplaySubject(1), 1);\n    this.readyState = ReadyState.Open;\n    this.request = req;\n  }\n/**\n *  Sends a mock response to the connection. This response is the value that is emitted to the {@link EventEmitter} returned by {@link Http}. * ### Example * ``` var connection; backend.connections.subscribe(c => connection = c); http.request('data.json').subscribe(res => console.log(res.text())); connection.mockRespond(new Response('fake response')); //logs 'fake response' ``` *\n * @param {?} res\n * @return {?}\n */\nmockRespond(res: Response) {\n    if (this.readyState === ReadyState.Done || this.readyState === ReadyState.Cancelled) {\n      throw new BaseException('Connection has already been resolved');\n    }\n    this.readyState = ReadyState.Done;\n    this.response.next(res);\n    this.response.complete();\n  }\n/**\n *  Not yet implemented! * Sends the provided {@link Response} to the `downloadObserver` of the `Request` associated with this connection.\n * @param {?} res\n * @return {?}\n */\nmockDownload(res: Response) {\n    // this.request.downloadObserver.onNext(res);\n    // if (res.bytesLoaded === res.totalBytes) {\n    //   this.request.downloadObserver.onCompleted();\n    // }\n  }\n/**\n *  Emits the provided error object as an error to the {@link Response} {@link EventEmitter} returned from {@link Http}.\n * @param {?=} err\n * @return {?}\n */\nmockError(err?: Error) {\n    // Matches XHR semantics\n    this.readyState = ReadyState.Done;\n    this.response.error(err);\n  }\n\n  static _tsickle_typeAnnotationsHelper() {\n /** Describes the state of the connection, based on `XMLHttpRequest.readyState`, but with additional states. For example, state 5 indicates an aborted connection.\n @type {?} */\nMockConnection.prototype.readyState;\n /** {@link Request} instance used to create the connection.\n @type {?} */\nMockConnection.prototype.request;\n /** {@link EventEmitter} of {@link Response}. Can be subscribed to in order to be notified when a response is available.\n @type {?} */\nMockConnection.prototype.response;\n  }\n\n}\nexport class MockBackend implements ConnectionBackend {\n  /**\n   * {@link EventEmitter}\n   * of {@link MockConnection} instances that have been created by this backend. Can be subscribed\n   * to in order to respond to connections.\n   *\n   * ### Example\n   *\n   * ```\n   * import {Http, BaseRequestOptions} from '@angular/http';\n   * import {MockBackend} from '@angular/http/testing';\n   * import {Injector} from '@angular/core';\n   *\n   * it('should get a response', () => {\n   *   var connection; //this will be set when a new connection is emitted from the backend.\n   *   var text; //this will be set from mock response\n   *   var injector = Injector.resolveAndCreate([\n   *     MockBackend,\n   *     provide(Http, {useFactory: (backend, options) => {\n   *       return new Http(backend, options);\n   *     }, deps: [MockBackend, BaseRequestOptions]}]);\n   *   var backend = injector.get(MockBackend);\n   *   var http = injector.get(Http);\n   *   backend.connections.subscribe(c => connection = c);\n   *   http.request('something.json').subscribe(res => {\n   *     text = res.text();\n   *   });\n   *   connection.mockRespond(new Response({body: 'Something'}));\n   *   expect(text).toBe('Something');\n   * });\n   * ```\n   *\n   * This property only exists in the mock implementation, not in real Backends.\n   */\n  connections: any;  //<MockConnection>\n\n  /**\n   * An array representation of `connections`. This array will be updated with each connection that\n   * is created by this backend.\n   *\n   * This property only exists in the mock implementation, not in real Backends.\n   */\n  connectionsArray: MockConnection[];\n  /**\n   * {@link EventEmitter} of {@link MockConnection} instances that haven't yet been resolved (i.e.\n   * with a `readyState`\n   * less than 4). Used internally to verify that no connections are pending via the\n   * `verifyNoPendingRequests` method.\n   *\n   * This property only exists in the mock implementation, not in real Backends.\n   */\n  pendingConnections: any;\n/**\n */\nconstructor() {\n    this.connectionsArray = [];\n    this.connections = new Subject();\n    this.connections.subscribe((connection: MockConnection) =>\n                                   this.connectionsArray.push(connection));\n    this.pendingConnections = new Subject();\n  }\n/**\n *  Checks all connections, and raises an exception if any connection has not received a response. * This method only exists in the mock implementation, not in real Backends.\n * @return {?}\n */\nverifyNoPendingRequests() {\n    let /** @type {?} */ pending = 0;\n    this.pendingConnections.subscribe((c: MockConnection) => pending++);\n    if (pending > 0) throw new BaseException(`${pending} pending connections to be resolved`);\n  }\n/**\n *  Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve connections, if it's expected that there are connections that have not yet received a response. * This method only exists in the mock implementation, not in real Backends.\n * @return {?}\n */\nresolveAllConnections() { this.connections.subscribe((c: MockConnection) => c.readyState = 4); }\n/**\n *  Creates a new {@link MockConnection}. This is equivalent to calling `new MockConnection()`, except that it also will emit the new `Connection` to the `connections` emitter of this `MockBackend` instance. This method will usually only be used by tests against the framework itself, not by end-users.\n * @param {?} req\n * @return {?}\n */\ncreateConnection(req: Request): MockConnection {\n    if (!isPresent(req) || !(req instanceof Request)) {\n      throw new BaseException(`createConnection requires an instance of Request, got ${req}`);\n    }\n    let /** @type {?} */ connection = new MockConnection(req);\n    this.connections.next(connection);\n    return connection;\n  }\n\n  static _tsickle_typeAnnotationsHelper() {\n /** {@link EventEmitter} of {@link MockConnection} instances that have been created by this backend. Can be subscribed to in order to respond to connections. * ### Example * ``` import {Http, BaseRequestOptions} from '@angular/http'; import {MockBackend} from '@angular/http/testing'; import {Injector} from '@angular/core'; * it('should get a response', () => { var connection; //this will be set when a new connection is emitted from the backend. var text; //this will be set from mock response var injector = Injector.resolveAndCreate([ MockBackend, provide(Http, {useFactory: (backend, options) => { return new Http(backend, options); }, deps: [MockBackend, BaseRequestOptions]}]); var backend = injector.get(MockBackend); var http = injector.get(Http); backend.connections.subscribe(c => connection = c); http.request('something.json').subscribe(res => { text = res.text(); }); connection.mockRespond(new Response({body: 'Something'})); expect(text).toBe('Something'); }); ``` * This property only exists in the mock implementation, not in real Backends.\n @type {?} */\nMockBackend.prototype.connections;\n /** An array representation of `connections`. This array will be updated with each connection that is created by this backend. * This property only exists in the mock implementation, not in real Backends.\n @type {?} */\nMockBackend.prototype.connectionsArray;\n /** {@link EventEmitter} of {@link MockConnection} instances that haven't yet been resolved (i.e. with a `readyState` less than 4). Used internally to verify that no connections are pending via the `verifyNoPendingRequests` method. * This property only exists in the mock implementation, not in real Backends.\n @type {?} */\nMockBackend.prototype.pendingConnections;\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */ static ctorParameters: {type: Function, decorators?: DecoratorInvocation[]}[] = [\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}