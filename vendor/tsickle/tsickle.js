"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ts = require('typescript');
var type_translator_1 = require('./type-translator');
var rewriter_1 = require('./rewriter');
var decorator_annotator_1 = require('./decorator-annotator');
exports.convertDecorators = decorator_annotator_1.convertDecorators;
/**
 * Symbols that are already declared as externs in Closure, that should
 * be avoided by tsickle's "declare ..." => externs.js conversion.
 */
exports.closureExternsBlacklist = [
    'exports',
    'global',
    'module',
    'WorkerGlobalScope',
    'Symbol',
];
function formatDiagnostics(diags) {
    return diags
        .map(function (d) {
        var res = ts.DiagnosticCategory[d.category];
        if (d.file) {
            res += ' at ' + d.file.fileName + ':';
            var _a = d.file.getLineAndCharacterOfPosition(d.start), line = _a.line, character = _a.character;
            res += (line + 1) + ':' + (character + 1) + ':';
        }
        res += ' ' + ts.flattenDiagnosticMessageText(d.messageText, '\n');
        return res;
    })
        .join('\n');
}
exports.formatDiagnostics = formatDiagnostics;
/**
 * getJSDocAnnotation parses JSDoc out of a comment string.
 * Returns null if comment is not JSDoc.
 */
function getJSDocAnnotation(comment) {
    // TODO(evanm): this is a pile of hacky regexes for now, because we
    // would rather use the better TypeScript implementation of JSDoc
    // parsing.  https://github.com/Microsoft/TypeScript/issues/7393
    var match = comment.match(/^\/\*\*([\s\S]*?)\*\/$/);
    if (!match)
        return null;
    comment = match[1].trim();
    // Strip all the " * " bits from the front of each line.
    comment = comment.replace(/^\s*\* /gm, '');
    var lines = comment.split('\n');
    var tags = [];
    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
        var line = lines_1[_i];
        match = line.match(/^@(\S+) *(.*)/);
        if (match) {
            var _ = match[0], tagName = match[1], text = match[2];
            if (tagName === 'type') {
                //throw new Error('@type annotations are not allowed');
                continue;
            }
            if ((tagName === 'param' || tagName === 'return') && text[0] === '{') {
                //throw new Error('type annotations (using {...}) are not allowed');
                continue;
            }
            // Grab the parameter name from @param tags.
            var parameterName = void 0;
            if (tagName === 'param') {
                match = text.match(/^(\S+) ?(.*)/);
                if (match)
                    _ = match[0], parameterName = match[1], text = match[2];
            }
            var tag = { tagName: tagName };
            if (parameterName)
                tag.parameterName = parameterName;
            if (text)
                tag.text = text;
            tags.push(tag);
        }
        else {
            // Text without a preceding @tag on it is either the plain text
            // documentation or a continuation of a previous tag.
            if (tags.length === 0) {
                tags.push({ text: line.trim() });
            }
            else {
                tags[tags.length - 1].text += ' ' + line.trim();
            }
        }
    }
    return { tags: tags };
}
exports.getJSDocAnnotation = getJSDocAnnotation;
var VISIBILITY_FLAGS = ts.NodeFlags.Private | ts.NodeFlags.Protected | ts.NodeFlags.Public;
/**
 * A source processor that takes TypeScript code and annotates the output with Closure-style JSDoc
 * comments.
 */
var Annotator = (function (_super) {
    __extends(Annotator, _super);
    function Annotator(program, file, options) {
        _super.call(this, file);
        this.program = program;
        this.options = options;
        /** Generated externs.js, if any. */
        this.externsOutput = [];
        /** Exported symbol names that have been generated by expanding an "export * from ...". */
        this.generatedExports = {};
        /** The set of namespaces that have already been emitted (through classes or modules). */
        this.emittedNamespaces = {};
    }
    Annotator.prototype.annotate = function () {
        this.visit(this.file);
        var externs = null;
        if (this.externsOutput.length > 0) {
            externs = '/** @externs */\n' + this.externsOutput.join('');
        }
        var _a = this.getOutput(), output = _a.output, diagnostics = _a.diagnostics;
        return {
            output: output,
            externs: externs,
            diagnostics: diagnostics
        };
    };
    /**
     * Examines a ts.Node and decides whether to do special processing of it for output.
     *
     * @return True if the ts.Node has been handled, false if we should
     *     emit it as is and visit its children.
     */
    Annotator.prototype.maybeProcess = function (node) {
        if (node.flags & ts.NodeFlags.Ambient) {
            this.visitExterns(node);
            // An ambient declaration declares types for TypeScript's benefit, so we want to skip Tsickle
            // conversion of its contents.
            this.writeRange(node.getFullStart(), node.getEnd());
            return true;
        }
        switch (node.kind) {
            case ts.SyntaxKind.ExportDeclaration:
                var exportDecl = node;
                if (!exportDecl.exportClause && exportDecl.moduleSpecifier) {
                    // It's an "export * from ..." statement.
                    // Rewrite it to re-export each exported symbol directly.
                    var exports_1 = this.expandSymbolsFromExportStar(exportDecl);
                    this.writeRange(exportDecl.getFullStart(), exportDecl.getStart());
                    this.emit("export {" + exports_1.join(',') + "} from");
                    this.writeRange(exportDecl.moduleSpecifier.getFullStart(), node.getEnd());
                    return true;
                }
                return false;
            case ts.SyntaxKind.InterfaceDeclaration:
                this.writeRange(node.getFullStart(), node.getEnd());
                return true;
            case ts.SyntaxKind.VariableDeclaration:
                var varDecl = node;
                // Only emit a type annotation when it's a plain variable and
                // not a binding pattern, as Closure doesn't(?) have a syntax
                // for annotating binding patterns.  See issue #128.
                if (varDecl.name.kind === ts.SyntaxKind.Identifier) {
                    this.emitJSDocType(varDecl);
                }
                return false;
            case ts.SyntaxKind.ClassDeclaration:
                var classNode = node;
                if (classNode.members.length > 0) {
                    // We must visit all members individually, to strip out any
                    // /** @export */ annotations that show up in the constructor
                    // and to annotate methods.
                    this.writeRange(classNode.getFullStart(), classNode.members[0].getFullStart());
                    for (var _i = 0, _a = classNode.members; _i < _a.length; _i++) {
                        var member = _a[_i];
                        this.visit(member);
                    }
                }
                else {
                    this.writeRange(classNode.getFullStart(), classNode.getLastToken().getFullStart());
                }
                this.emitTypeAnnotationsHelper(classNode);
                this.writeNode(classNode.getLastToken());
                return true;
            case ts.SyntaxKind.PublicKeyword:
            case ts.SyntaxKind.PrivateKeyword:
                // The "public"/"private" keywords are encountered in two places:
                // 1) In class fields (which don't appear in the transformed output).
                // 2) In "parameter properties", e.g.
                //      constructor(/** @export */ public foo: string).
                // In case 2 it's important to not emit that JSDoc in the generated
                // constructor, as this is illegal for Closure.  It's safe to just
                // always skip comments preceding the 'public' keyword.
                // See test_files/parameter_properties.ts.
                this.writeNode(node, /* skipComments */ true);
                return true;
            case ts.SyntaxKind.Constructor:
                var ctor = node;
                this.emitFunctionType(ctor);
                // Write the "constructor(...) {" bit, but iterate through any
                // parameters if given so that we can examine them more closely.
                var offset = ctor.getStart();
                if (ctor.parameters.length) {
                    for (var _b = 0, _c = ctor.parameters; _b < _c.length; _b++) {
                        var param = _c[_b];
                        this.writeRange(offset, param.getFullStart());
                        this.visit(param);
                        offset = param.getEnd();
                    }
                }
                this.writeRange(offset, node.getEnd());
                return true;
            case ts.SyntaxKind.ArrowFunction:
                // It's difficult to annotate arrow functions due to a bug in
                // TypeScript (see tsickle issue 57).  For now, just pass them
                // through unannotated.
                return false;
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.MethodDeclaration:
                var fnDecl = node;
                if (!fnDecl.body) {
                    // Functions are allowed to not have bodies in the presence
                    // of overloads.  It's not clear how to translate these overloads
                    // into Closure types, so skip them for now.
                    return false;
                }
                this.emitFunctionType(fnDecl);
                this.writeRange(fnDecl.getStart(), fnDecl.body.getFullStart());
                this.visit(fnDecl.body);
                return true;
            case ts.SyntaxKind.TypeAliasDeclaration:
                this.visitTypeAlias(node);
                this.writeNode(node);
                return true;
            case ts.SyntaxKind.EnumDeclaration:
                return this.maybeProcessEnum(node);
            case ts.SyntaxKind.TypeAssertionExpression:
                var typeAssertion = node;
                this.emitJSDocType(typeAssertion);
                // When TypeScript emits JS, it removes one layer of "redundant"
                // parens, but we need them for the Closure type assertion.  Work
                // around this by using two parens.  See test_files/coerce.*.
                this.emit('((');
                this.writeNode(node);
                this.emit('))');
                return true;
            default:
                break;
        }
        return false;
    };
    Annotator.prototype.expandSymbolsFromExportStar = function (exportDecl) {
        var typeChecker = this.program.getTypeChecker();
        // Gather the names of local exports, to avoid reexporting any
        // names that are already locally exported.
        // To find symbols declared like
        //   export {foo} from ...
        // we must also query for "Alias", but that unfortunately also brings in
        //   import {foo} from ...
        // so the latter is filtered below.
        var locals = typeChecker.getSymbolsInScope(this.file, ts.SymbolFlags.Export | ts.SymbolFlags.Alias);
        var localSet = {};
        for (var _i = 0, locals_1 = locals; _i < locals_1.length; _i++) {
            var local = locals_1[_i];
            if (local.declarations.some(function (d) { return d.kind === ts.SyntaxKind.ImportSpecifier; })) {
                continue;
            }
            localSet[local.name] = true;
        }
        // Expand the export list, then filter it to the symbols we want
        // to reexport
        var exports = typeChecker.getExportsOfModule(typeChecker.getSymbolAtLocation(exportDecl.moduleSpecifier));
        var reexports = {};
        for (var _a = 0, exports_2 = exports; _a < exports_2.length; _a++) {
            var sym = exports_2[_a];
            var name_1 = sym.name;
            if (localSet.hasOwnProperty(name_1)) {
                // This name is shadowed by a local definition, such as:
                // - export var foo ...
                // - export {foo} from ...
                continue;
            }
            if (this.generatedExports.hasOwnProperty(name_1)) {
                // Already exported via an earlier expansion of an "export * from ...".
                continue;
            }
            this.generatedExports[name_1] = true;
            reexports[name_1] = true;
        }
        return Object.keys(reexports);
    };
    Annotator.prototype.emitFunctionType = function (fnDecl, extraTags) {
        if (extraTags === void 0) { extraTags = []; }
        var typeChecker = this.program.getTypeChecker();
        var sig = typeChecker.getSignatureFromDeclaration(fnDecl);
        // Construct the JSDoc comment by reading the existing JSDoc, if
        // any, and merging it with the known types of the function
        // parameters and return type.
        var jsDoc = this.getJSDoc(fnDecl) || { tags: [] };
        var newDoc = { tags: extraTags };
        // Copy all the tags other than @param/@return into the new
        // comment without any change; @param/@return are handled later.
        for (var _i = 0, _a = jsDoc.tags; _i < _a.length; _i++) {
            var tag = _a[_i];
            if (tag.tagName === 'param' || tag.tagName === 'return')
                continue;
            newDoc.tags.push(tag);
        }
        // Parameters.
        if (sig.parameters.length) {
            // Iterate through both the AST parameter list and the type's parameter
            // list, as some information is only available in the former.
            for (var i = 0; i < sig.parameters.length; i++) {
                var paramNode = fnDecl.parameters[i];
                var paramSym = sig.parameters[i];
                var type = typeChecker.getTypeOfSymbolAtLocation(paramSym, fnDecl);
                var newTag = {
                    tagName: 'param',
                    optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,
                    parameterName: paramSym.name
                };
                var destructuring = (paramNode.name.kind === ts.SyntaxKind.ArrayBindingPattern ||
                    paramNode.name.kind === ts.SyntaxKind.ObjectBindingPattern);
                if (paramNode.dotDotDotToken !== undefined) {
                    newTag.restParam = true;
                    // In TypeScript you write "...x: number[]", but in Closure
                    // you don't write the array: "@param {...number} x".  Unwrap
                    // the Array<> wrapper.
                    type = type.typeArguments[0];
                }
                newTag.type = this.typeToClosure(fnDecl, type, destructuring);
                // Search for this parameter in the JSDoc @params.
                for (var _b = 0, _c = jsDoc.tags; _b < _c.length; _b++) {
                    var _d = _c[_b], tagName = _d.tagName, parameterName = _d.parameterName, text = _d.text;
                    if (tagName === 'param' && parameterName === paramSym.name) {
                        newTag.text = text;
                        break;
                    }
                }
                newDoc.tags.push(newTag);
            }
        }
        // Return type.
        if (fnDecl.kind !== ts.SyntaxKind.Constructor) {
            var retType = typeChecker.getReturnTypeOfSignature(sig);
            var returnDoc = void 0;
            for (var _e = 0, _f = jsDoc.tags; _e < _f.length; _e++) {
                var _g = _f[_e], tagName = _g.tagName, text = _g.text;
                if (tagName === 'return') {
                    returnDoc = text;
                    break;
                }
            }
            newDoc.tags.push({
                tagName: 'return',
                type: this.typeToClosure(fnDecl, retType),
                text: returnDoc
            });
        }
        // The first \n makes the output sometimes uglier than necessary,
        // but it's needed to work around
        // https://github.com/Microsoft/TypeScript/issues/6982
        this.emit('\n/**\n');
        for (var _h = 0, _j = newDoc.tags; _h < _j.length; _h++) {
            var tag = _j[_h];
            this.emit(' * ');
            if (tag.tagName) {
                this.emit("@" + tag.tagName);
            }
            if (tag.type) {
                this.emit(' {');
                if (tag.restParam) {
                    this.emit('...');
                }
                this.emit(tag.type);
                if (tag.optional) {
                    this.emit('=');
                }
                this.emit('}');
            }
            if (tag.parameterName) {
                this.emit(' ' + tag.parameterName);
            }
            if (tag.text) {
                this.emit(' ' + tag.text);
            }
            this.emit('\n');
        }
        this.emit(' */\n');
    };
    // emitTypeAnnotationsHelper produces a
    // _tsickle_typeAnnotationsHelper() where none existed in the
    // original source.  It's necessary in the case where TypeScript
    // syntax specifies there are additional properties on the class,
    // because to declare these in Closure you must declare these in a
    // method somewhere.
    Annotator.prototype.emitTypeAnnotationsHelper = function (classDecl) {
        var _this = this;
        // Gather parameter properties from the constructor, if it exists.
        var ctors = [];
        var paramProps = [];
        var nonStaticProps = [];
        var staticProps = [];
        for (var _i = 0, _a = classDecl.members; _i < _a.length; _i++) {
            var member = _a[_i];
            if (member.kind === ts.SyntaxKind.Constructor) {
                ctors.push(member);
            }
            else if (member.kind === ts.SyntaxKind.PropertyDeclaration) {
                var prop = member;
                var isStatic = (prop.flags & ts.NodeFlags.Static) !== 0;
                if (isStatic) {
                    staticProps.push(prop);
                }
                else {
                    nonStaticProps.push(prop);
                }
            }
        }
        if (ctors.length > 0) {
            var ctor = ctors[0];
            paramProps = ctor.parameters.filter(function (p) { return !!(p.flags & VISIBILITY_FLAGS); });
        }
        if (nonStaticProps.length === 0 && paramProps.length === 0 && staticProps.length === 0) {
            // There are no members so we don't need to emit any type
            // annotations helper.
            return;
        }
        this.emit('\n\n  static _tsickle_typeAnnotationsHelper() {\n');
        staticProps.forEach(function (p) { return _this.visitProperty([classDecl.name.text], p); });
        var memberNamespace = [classDecl.name.text, 'prototype'];
        nonStaticProps.forEach(function (p) { return _this.visitProperty(memberNamespace, p); });
        paramProps.forEach(function (p) { return _this.visitProperty(memberNamespace, p); });
        this.emit('  }\n');
    };
    Annotator.prototype.visitProperty = function (namespace, p) {
        var jsDoc = this.getJSDoc(p) || { tags: [] };
        var existingAnnotation = '';
        for (var _i = 0, _a = jsDoc.tags; _i < _a.length; _i++) {
            var _b = _a[_i], tagName = _b.tagName, text = _b.text;
            if (tagName) {
                existingAnnotation += "@" + tagName + "\n";
            }
            else {
                existingAnnotation += text + "\n";
            }
        }
        this.emit(' /**');
        if (existingAnnotation) {
            this.emit(' ' + existingAnnotation);
        }
        this.emit(" @type {" + this.typeToClosure(p) + "} */\n");
        namespace = namespace.concat([p.name.getText()]);
        this.emit(namespace.join('.') + ";\n");
    };
    /**
     * Returns null if there is no existing comment.
     */
    Annotator.prototype.getJSDoc = function (node) {
        var text = node.getFullText();
        var comments = ts.getLeadingCommentRanges(text, 0);
        if (!comments || comments.length === 0)
            return null;
        // JS compiler only considers the last comment significant.
        var _a = comments[comments.length - 1], pos = _a.pos, end = _a.end;
        var comment = text.substring(pos, end);
        try {
            return getJSDocAnnotation(comment);
        }
        catch (e) {
            this.error(node, e.message, node.getFullStart() + pos);
            return null;
        }
    };
    Annotator.prototype.visitExterns = function (node, namespace) {
        if (namespace === void 0) { namespace = []; }
        var originalOutput = this.output;
        this.output = this.externsOutput;
        switch (node.kind) {
            case ts.SyntaxKind.ModuleDeclaration:
                var decl = node;
                switch (decl.name.kind) {
                    case ts.SyntaxKind.Identifier:
                        // E.g. "declare namespace foo {"
                        namespace = namespace.concat(decl.name.text);
                        var nsName = namespace.join('.');
                        if (!this.emittedNamespaces.hasOwnProperty(nsName)) {
                            this.emit('/** @const */\n');
                            if (namespace.length > 1) {
                                this.emit(namespace.join('.') + " = {};\n");
                            }
                            else {
                                this.emit("var " + namespace + " = {};\n");
                            }
                        }
                        this.emittedNamespaces[nsName] = true;
                        this.visitExterns(decl.body, namespace);
                        break;
                    case ts.SyntaxKind.StringLiteral:
                        // E.g. "declare module 'foo' {" (note the quotes).
                        // Skip it.
                        break;
                    default:
                        this.errorUnimplementedKind(decl.name, 'externs generation of namespace');
                }
                break;
            case ts.SyntaxKind.ModuleBlock:
                var block = node;
                for (var _i = 0, _a = block.statements; _i < _a.length; _i++) {
                    var stmt = _a[_i];
                    this.visitExterns(stmt, namespace);
                }
                break;
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
                this.writeExternsType(node, namespace);
                break;
            case ts.SyntaxKind.FunctionDeclaration:
                var f = node;
                this.emitFunctionType(f);
                var params = f.parameters.map(function (p) { return p.name.getText(); });
                this.writeExternsFunction(f.name.getText(), params.join(', '), namespace);
                break;
            case ts.SyntaxKind.VariableStatement:
                for (var _b = 0, _c = node.declarationList.declarations; _b < _c.length; _b++) {
                    var decl_1 = _c[_b];
                    this.writeExternsVariable(decl_1, namespace);
                }
                break;
            default:
                this.emit("\n/* TODO: " + ts.SyntaxKind[node.kind] + " in " + namespace.join('.') + " */\n");
                break;
        }
        this.output = originalOutput;
    };
    Annotator.prototype.writeExternsType = function (decl, namespace) {
        var typeName = namespace.concat([decl.name.getText()]).join('.');
        this.emittedNamespaces[typeName] = true;
        if (exports.closureExternsBlacklist.indexOf(typeName) >= 0)
            return;
        this.emittedNamespaces[typeName] = true;
        var paramNames = '';
        if (decl.kind === ts.SyntaxKind.ClassDeclaration) {
            var ctors = decl.members.filter(function (m) { return m.kind === ts.SyntaxKind.Constructor; });
            if (ctors.length) {
                if (ctors.length > 1) {
                    this.error(ctors[1], 'multiple constructor signatures in declarations');
                }
                var ctor = ctors[0];
                this.emitFunctionType(ctor, [{ tagName: 'constructor' }, { tagName: 'struct' }]);
                paramNames = ctor.parameters.map(function (p) { return p.name.getText(); }).join(', ');
            }
            else {
                this.emit('/** @constructor @struct */\n');
            }
        }
        else {
            this.emit('/** @record @struct */\n');
        }
        this.writeExternsFunction(decl.name.getText(), paramNames, namespace);
        for (var _i = 0, _a = decl.members; _i < _a.length; _i++) {
            var member = _a[_i];
            switch (member.kind) {
                case ts.SyntaxKind.PropertySignature:
                case ts.SyntaxKind.PropertyDeclaration:
                    var prop = member;
                    this.emitJSDocType(prop);
                    this.emit("\n" + typeName + ".prototype." + prop.name.getText() + ";\n");
                    break;
                case ts.SyntaxKind.MethodDeclaration:
                    var m = member;
                    this.emitFunctionType(m);
                    this.emit((typeName + ".prototype." + m.name.getText() + " = ") +
                        ("function(" + m.parameters.map(function (p) { return p.name.getText(); }).join(', ') + ") {};\n"));
                    break;
                case ts.SyntaxKind.Constructor:
                    break; // Handled above.
                default:
                    // Members can include things like index signatures, for e.g.
                    //   interface Foo { [key: string]: number; }
                    // For now, just die unless all the members are regular old
                    // properties.
                    var name_2 = namespace;
                    if (member.name) {
                        name_2 = name_2.concat([member.name.getText()]);
                    }
                    this.emit("\n/* TODO: " + ts.SyntaxKind[member.kind] + " in " + name_2.join('.') + " */\n");
            }
        }
    };
    Annotator.prototype.writeExternsVariable = function (decl, namespace) {
        if (decl.name.kind === ts.SyntaxKind.Identifier) {
            var identifier = decl.name;
            var qualifiedName = namespace.concat([identifier.text]).join('.');
            if (exports.closureExternsBlacklist.indexOf(qualifiedName) >= 0)
                return;
            this.emitJSDocType(decl);
            if (namespace.length > 0) {
                this.emit("\n" + qualifiedName + ";\n");
            }
            else {
                this.emit("\nvar " + qualifiedName + ";\n");
            }
        }
        else {
            this.errorUnimplementedKind(decl.name, 'externs for variable');
        }
    };
    Annotator.prototype.writeExternsFunction = function (name, params, namespace) {
        if (namespace.length > 0) {
            name = namespace.concat([name]).join('.');
            this.emit(name + " = function(" + params + ") {};\n");
        }
        else {
            this.emit("function " + name + "(" + params + ") {}\n");
        }
    };
    /** Emits a type annotation in JSDoc, or {?} if the type is unavailable. */
    Annotator.prototype.emitJSDocType = function (node, additionalDocTag) {
        this.emit(' /**');
        if (additionalDocTag) {
            this.emit(' ' + additionalDocTag);
        }
        this.emit(" @type {" + this.typeToClosure(node) + "} */");
    };
    /**
     * Convert a TypeScript ts.Type into the equivalent Closure type.
     *
     * @param context The ts.Node containing the type reference; used for resolving symbols
     *     in context.
     * @param type The type to translate; if not provided, the Node's type will be used.
     * @param destructuring If true, insert a Closure "!" (not-null annotation) on all
     *     object/array types.  This is a workaround specifically for destructuring
     *     bind patterns.
     */
    Annotator.prototype.typeToClosure = function (context, type, destructuring) {
        var _this = this;
        if (this.options.untyped) {
            return '?';
        }
        var typeChecker = this.program.getTypeChecker();
        if (!type) {
            type = typeChecker.getTypeAtLocation(context);
        }
        var translator = new type_translator_1.TypeTranslator(typeChecker, context);
        translator.warn = function (msg) { return _this.debugWarn(context, msg); };
        return translator.translate(type, destructuring);
    };
    Annotator.prototype.visitTypeAlias = function (node) {
        if (this.options.untyped)
            return;
        // Write a Closure typedef, which involves an unused "var" declaration.
        this.emit("/** @typedef {" + this.typeToClosure(node) + "} */\n");
        this.emit("var " + node.name.getText() + ": void;\n");
    };
    /** Processes an EnumDeclaration or returns false for ordinary processing. */
    Annotator.prototype.maybeProcessEnum = function (node) {
        if (node.flags & ts.NodeFlags.Const) {
            // const enums disappear after TS compilation and consequently need no
            // help from tsickle.
            return false;
        }
        // Gather the members of enum, saving the constant value or
        // initializer expression in the case of a non-constant value.
        var members = {};
        var i = 0;
        for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
            var member = _a[_i];
            var memberName = member.name.getText();
            if (member.initializer) {
                var enumConstValue = this.program.getTypeChecker().getConstantValue(member);
                if (enumConstValue !== undefined) {
                    members[memberName] = enumConstValue;
                    i = enumConstValue + 1;
                }
                else {
                    // Non-constant enum value.  Save the initializer expression for
                    // emitting as-is.
                    // Note: if the member's initializer expression refers to another
                    // value within the enum (e.g. something like
                    //   enum Foo {
                    //     Field1,
                    //     Field2 = Field1 + something(),
                    //   }
                    // Then when we emit the initializer we produce invalid code because
                    // on the Closure side it has to be written "Foo.Field1 + something()".
                    // Hopefully this doesn't come up often -- if the enum instead has
                    // something like
                    //     Field2 = Field1 + 3,
                    // then it's still a constant expression and we inline the constant
                    // value in the above branch of this "if" statement.
                    members[memberName] = member.initializer;
                }
            }
            else {
                members[memberName] = i;
                i++;
            }
        }
        // Emit the enum declaration, which looks like:
        //   type Foo = number;
        //   let Foo: any = {};
        // We use an "any" here rather than a more specific type because
        // we think TypeScript has already checked types for us, and it's
        // a bit difficult to provide a type that matches all the interfaces
        // expected of an enum (in particular, it is keyable both by
        // string and number).
        // We don't emit a specific Closure type for the enum because it's
        // also difficult to make work: for example, we can't make the name
        // both a typedef and an indexable object if we export it.
        this.emit('\n');
        var name = node.name.getText();
        if (node.flags & ts.NodeFlags.Export) {
            this.emit('export ');
        }
        this.emit("type " + name + " = number;\n");
        if (node.flags & ts.NodeFlags.Export) {
            this.emit('export ');
        }
        this.emit("let " + name + ": any = {};\n");
        // Emit foo.BAR = 0; lines.
        for (var _b = 0, _c = Object.keys(members); _b < _c.length; _b++) {
            var member = _c[_b];
            if (!this.options.untyped)
                this.emit("/** @type {number} */\n");
            this.emit(name + "." + member + " = ");
            var value = members[member];
            if (typeof value === 'number') {
                this.emit(value.toString());
            }
            else {
                this.visit(value);
            }
            this.emit(';\n');
        }
        // Emit foo[foo.BAR] = 'BAR'; lines.
        for (var _d = 0, _e = Object.keys(members); _d < _e.length; _d++) {
            var member = _e[_d];
            this.emit(name + "[" + name + "." + member + "] = \"" + member + "\";\n");
        }
        return true;
    };
    /**
     * debug logs a debug warning.  These should only be used for cases
     * where tsickle is making a questionable judgement about what to do.
     * By default, tsickle does not report any warnings to the caller,
     * and warnings are hidden behind a debug flag, as warnings are only
     * for tsickle to debug itself.
     */
    Annotator.prototype.debugWarn = function (node, messageText) {
        if (!this.options.logWarning)
            return;
        // Use a ts.Diagnosic so that the warning includes context and file offets.
        var diagnostic = {
            file: this.file,
            start: node.getStart(),
            length: node.getEnd() - node.getStart(), messageText: messageText,
            category: ts.DiagnosticCategory.Warning,
            code: undefined
        };
        this.options.logWarning(diagnostic);
    };
    return Annotator;
}(rewriter_1.Rewriter));
function annotate(program, file, options) {
    if (options === void 0) { options = {}; }
    return new Annotator(program, file, options).annotate();
}
exports.annotate = annotate;
/**
 * PostProcessor postprocesses TypeScript compilation output JS, to rewrite commonjs require()s into
 * goog.require().
 */
var PostProcessor = (function (_super) {
    __extends(PostProcessor, _super);
    function PostProcessor(file, pathToModuleName) {
        _super.call(this, file);
        this.pathToModuleName = pathToModuleName;
        /**
         * namespaceImports collects the variables for imported goog.modules.
         * If the original TS input is:
         *   import foo from 'goog:bar';
         * then TS produces:
         *   var foo = require('goog:bar');
         * and this class rewrites it to:
         *   var foo = require('goog.bar');
         * After this step, namespaceImports['foo'] is true.
         * (This is used to rewrite 'foo.default' into just 'foo'.)
         */
        this.namespaceImports = {};
        /**
         * moduleVariables maps from module names to the variables they're assigned to.
         * Continuing the above example, moduleVariables['goog.bar'] = 'foo'.
         */
        this.moduleVariables = {};
        /** strippedStrict is true once we've stripped a "use strict"; from the input. */
        this.strippedStrict = false;
        /** unusedIndex is used to generate fresh symbols for unnamed imports. */
        this.unusedIndex = 0;
    }
    PostProcessor.prototype.process = function () {
        // TODO(evanm): only emit the goog.module *after* the first comment,
        // so that @suppress statements work.
        var moduleName = this.pathToModuleName('', this.file.fileName);
        // NB: No linebreak after module call so sourcemaps are not offset.
        this.emit("goog.module('" + moduleName + "');");
        var pos = 0;
        for (var _i = 0, _a = this.file.statements; _i < _a.length; _i++) {
            var stmt = _a[_i];
            this.writeRange(pos, stmt.getFullStart());
            this.visitTopLevel(stmt);
            pos = stmt.getEnd();
        }
        this.writeRange(pos, this.file.getEnd());
        var referencedModules = Object.keys(this.moduleVariables);
        // Note: don't sort referencedModules, as the keys are in the same order
        // they occur in the source file.
        var output = this.getOutput().output;
        return { output: output, referencedModules: referencedModules };
    };
    /**
     * visitTopLevel processes a top-level ts.Node and emits its contents.
     *
     * It's separate from the normal Rewriter recursive traversal
     * because some top-level statements are handled specially.
     */
    PostProcessor.prototype.visitTopLevel = function (node) {
        switch (node.kind) {
            case ts.SyntaxKind.ExpressionStatement:
                // Check for "use strict" and skip it if necessary.
                if (!this.strippedStrict && this.isUseStrict(node)) {
                    this.writeRange(node.getFullStart(), node.getStart());
                    this.strippedStrict = true;
                    return;
                }
                // Check for:
                // - "require('foo');" (a require for its side effects)
                // - "__export(require(...));" (an "export * from ...")
                if (this.emitRewrittenRequires(node)) {
                    return;
                }
                // Otherwise fall through to default processing.
                break;
            case ts.SyntaxKind.VariableStatement:
                // Check for a "var x = require('foo');".
                if (this.emitRewrittenRequires(node))
                    return;
                break;
            default:
                break;
        }
        this.visit(node);
    };
    /** isUseStrict returns true if node is a "use strict"; statement. */
    PostProcessor.prototype.isUseStrict = function (node) {
        if (node.kind !== ts.SyntaxKind.ExpressionStatement)
            return false;
        var exprStmt = node;
        var expr = exprStmt.expression;
        if (expr.kind !== ts.SyntaxKind.StringLiteral)
            return false;
        var literal = expr;
        return literal.text === 'use strict';
    };
    /**
     * emitRewrittenRequires rewrites require()s into goog.require() equivalents.
     *
     * @return True if the node was rewritten, false if needs ordinary processing.
     */
    PostProcessor.prototype.emitRewrittenRequires = function (node) {
        // We're looking for requires, of one of the forms:
        // - "var importName = require(...);".
        // - "require(...);".
        // Find the CallExpression contained in either of these.
        var varName; // E.g. importName in the above example.
        var call; // The require(...) expression.
        if (node.kind === ts.SyntaxKind.VariableStatement) {
            // It's possibly of the form "var x = require(...);".
            var varStmt = node;
            // Verify it's a single decl (and not "var x = ..., y = ...;").
            if (varStmt.declarationList.declarations.length !== 1)
                return false;
            var decl = varStmt.declarationList.declarations[0];
            // Grab the variable name (avoiding things like destructuring binds).
            if (decl.name.kind !== ts.SyntaxKind.Identifier)
                return false;
            varName = decl.name.text;
            if (!decl.initializer || decl.initializer.kind !== ts.SyntaxKind.CallExpression)
                return false;
            call = decl.initializer;
        }
        else if (node.kind === ts.SyntaxKind.ExpressionStatement) {
            // It's possibly of the form:
            // - require(...);
            // - __export(require(...));
            // Both are CallExpressions.
            var exprStmt = node;
            var expr = exprStmt.expression;
            if (expr.kind !== ts.SyntaxKind.CallExpression)
                return false;
            call = expr;
            var require_1 = this.isExportRequire(call);
            if (require_1) {
                var modName_1 = this.pathToModuleName(this.file.fileName, require_1);
                this.writeRange(node.getFullStart(), node.getStart());
                this.emit("__export(goog.require('" + modName_1 + "'));");
                // Mark that this module was imported; it doesn't have an associated
                // variable so just call the variable "*".
                this.moduleVariables[modName_1] = '*';
                return true;
            }
        }
        else {
            // It's some other type of statement.
            return false;
        }
        var require = this.isRequire(call);
        if (!require)
            return false;
        // Even if it's a bare require(); statement, introduce a variable for it.
        // This avoids a Closure error.
        if (!varName) {
            varName = "unused_" + this.unusedIndex++ + "_";
        }
        var modName;
        if (require.match(/^goog:/)) {
            // This is a namespace import, of the form "goog:foo.bar".
            // Fix it to just "foo.bar", and save the variable name.
            modName = require.substr(5);
            this.namespaceImports[varName] = true;
        }
        else {
            modName = this.pathToModuleName(this.file.fileName, require);
        }
        this.writeRange(node.getFullStart(), node.getStart());
        if (this.moduleVariables.hasOwnProperty(modName)) {
            this.emit("var " + varName + " = " + this.moduleVariables[modName] + ";");
        }
        else {
            this.emit("var " + varName + " = goog.require('" + modName + "');");
            this.moduleVariables[modName] = varName;
        }
        return true;
    };
    /**
     * Returns the string argument if call is of the form
     *   require('foo')
     */
    PostProcessor.prototype.isRequire = function (call) {
        // Verify that the call is a call to require(...).
        if (call.expression.kind !== ts.SyntaxKind.Identifier)
            return null;
        var ident = call.expression;
        if (ident.text !== 'require')
            return null;
        // Verify the call takes a single string argument and grab it.
        if (call.arguments.length !== 1)
            return null;
        var arg = call.arguments[0];
        if (arg.kind !== ts.SyntaxKind.StringLiteral)
            return null;
        return arg.text;
    };
    /**
     * Returns the inner string if call is of the form
     *   __export(require('foo'))
     */
    PostProcessor.prototype.isExportRequire = function (call) {
        if (call.expression.kind !== ts.SyntaxKind.Identifier)
            return null;
        var ident = call.expression;
        if (ident.getText() !== '__export')
            return null;
        // Verify the call takes a single string argument and grab it.
        if (call.arguments.length !== 1)
            return null;
        var arg = call.arguments[0];
        if (arg.kind !== ts.SyntaxKind.CallExpression)
            return null;
        return this.isRequire(arg);
    };
    /**
     * maybeProcess is called during the recursive traversal of the program's AST.
     *
     * @return True if the node was processed/emitted, false if it should be emitted as is.
     */
    PostProcessor.prototype.maybeProcess = function (node) {
        switch (node.kind) {
            case ts.SyntaxKind.PropertyAccessExpression:
                var propAccess = node;
                // We're looking for an expression of the form:
                //   module_name_var.default
                if (propAccess.name.text !== 'default')
                    break;
                if (propAccess.expression.kind !== ts.SyntaxKind.Identifier)
                    break;
                var lhsIdent = propAccess.expression;
                if (!this.namespaceImports.hasOwnProperty(lhsIdent.text))
                    break;
                // Emit the same expression, with spaces to replace the ".default" part
                // so that source maps still line up.
                this.writeRange(node.getFullStart(), node.getStart());
                this.emit(lhsIdent.text + "        ");
                return true;
            default:
                break;
        }
        return false;
    };
    return PostProcessor;
}(rewriter_1.Rewriter));
/**
 * Converts TypeScript's JS+CommonJS output to Closure goog.module etc.
 * For use as a postprocessing step *after* TypeScript emits JavaScript.
 *
 * @param fileName The source file name, without an extension.
 * @param pathToModuleName A function that maps a filesystem .ts path to a
 *     Closure module name, as found in a goog.require('...') statement.
 *     The context parameter is the referencing file, used for resolving
 *     imports with relative paths like "import * as foo from '../foo';".
 */
function convertCommonJsToGoogModule(fileName, content, pathToModuleName) {
    var file = ts.createSourceFile(fileName, content, ts.ScriptTarget.ES5, true);
    return new PostProcessor(file, pathToModuleName).process();
}
exports.convertCommonJsToGoogModule = convertCommonJsToGoogModule;

//# sourceMappingURL=tsickle.js.map
