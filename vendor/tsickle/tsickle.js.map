{"version":3,"sources":["tsickle.ts"],"names":[],"mappings":"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","file":"tsickle.js","sourcesContent":["import * as ts from 'typescript';\nimport {TypeTranslator} from './type-translator';\nimport {Rewriter} from './rewriter';\nexport {convertDecorators} from './decorator-annotator';\n\nexport interface Options {\n  // If true, convert every type to the Closure {?} type, which means\n  // \"don't check types\".\n  untyped?: boolean;\n  // If provided a function that logs an internal warning.\n  // These warnings are not actionable by an end user and should be hidden\n  // by default.\n  logWarning?: (warning: ts.Diagnostic) => void;\n}\n\nexport interface Output {\n  // The TypeScript source with Closure annotations inserted.\n  output: string;\n  // Generated externs declarations, if any.\n  externs: string;\n  // Error messages, if any.\n  diagnostics: ts.Diagnostic[];\n}\n\n/**\n * Symbols that are already declared as externs in Closure, that should\n * be avoided by tsickle's \"declare ...\" => externs.js conversion.\n */\nexport let closureExternsBlacklist: string[] = [\n  'exports',\n  'global',\n  'module',\n  'WorkerGlobalScope',\n  'Symbol',\n];\n\nexport function formatDiagnostics(diags: ts.Diagnostic[]): string {\n  return diags\n      .map((d) => {\n        let res = ts.DiagnosticCategory[d.category];\n        if (d.file) {\n          res += ' at ' + d.file.fileName + ':';\n          let {line, character} = d.file.getLineAndCharacterOfPosition(d.start);\n          res += (line + 1) + ':' + (character + 1) + ':';\n        }\n        res += ' ' + ts.flattenDiagnosticMessageText(d.messageText, '\\n');\n        return res;\n      })\n      .join('\\n');\n}\n\n/**\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier.  See e.g. ts.JSDocTag and ts.JSDocComment.\n */\nexport interface JSDocTag {\n  // tagName is e.g. \"param\" in an @param declaration.  It's absent\n  // for the plain text documentation that occurs before any @foo lines.\n  tagName?: string;\n  // parameterName is the the name of the function parameter, e.g. \"foo\"\n  // in\n  //   @param foo The foo param.\n  parameterName?: string;\n  type?: string;\n  // optional is true for optional function parameters.\n  optional?: boolean;\n  // restParam is true for \"...x: foo[]\" function parameters.\n  restParam?: boolean;\n  // destructuring is true for destructuring bind parameters, which require\n  // non-null arguments on the Closure side.  Can likely remove this\n  // once TypeScript nullable types are available.\n  destructuring?: boolean;\n  text?: string;\n}\n\nexport interface JSDocComment { tags: JSDocTag[]; }\n\n/**\n * getJSDocAnnotation parses JSDoc out of a comment string.\n * Returns null if comment is not JSDoc.\n */\nexport function getJSDocAnnotation(comment: string): JSDocComment {\n  // TODO(evanm): this is a pile of hacky regexes for now, because we\n  // would rather use the better TypeScript implementation of JSDoc\n  // parsing.  https://github.com/Microsoft/TypeScript/issues/7393\n  let match = comment.match(/^\\/\\*\\*([\\s\\S]*?)\\*\\/$/);\n  if (!match) return null;\n  comment = match[1].trim();\n  // Strip all the \" * \" bits from the front of each line.\n  comment = comment.replace(/^\\s*\\* /gm, '');\n  let lines = comment.split('\\n');\n  let tags: JSDocTag[] = [];\n  for (let line of lines) {\n    match = line.match(/^@(\\S+) *(.*)/);\n    if (match) {\n      let [_, tagName, text] = match;\n      if (tagName === 'type') {\n        //throw new Error('@type annotations are not allowed');\n        continue;\n      }\n      if ((tagName === 'param' || tagName === 'return') && text[0] === '{') {\n        //throw new Error('type annotations (using {...}) are not allowed');\n        continue;\n      }\n\n      // Grab the parameter name from @param tags.\n      let parameterName: string;\n      if (tagName === 'param') {\n        match = text.match(/^(\\S+) ?(.*)/);\n        if (match) [_, parameterName, text] = match;\n      }\n\n      let tag: JSDocTag = {tagName};\n      if (parameterName) tag.parameterName = parameterName;\n      if (text) tag.text = text;\n      tags.push(tag);\n    } else {\n      // Text without a preceding @tag on it is either the plain text\n      // documentation or a continuation of a previous tag.\n      if (tags.length === 0) {\n        tags.push({text: line.trim()});\n      } else {\n        tags[tags.length - 1].text += ' ' + line.trim();\n      }\n    }\n  }\n  return {tags};\n}\n\n\nconst VISIBILITY_FLAGS = ts.NodeFlags.Private | ts.NodeFlags.Protected | ts.NodeFlags.Public;\n\n/**\n * A source processor that takes TypeScript code and annotates the output with Closure-style JSDoc\n * comments.\n */\nclass Annotator extends Rewriter {\n  /** Generated externs.js, if any. */\n  private externsOutput: string[] = [];\n  /** Exported symbol names that have been generated by expanding an \"export * from ...\". */\n  private generatedExports: {[symbol: string]: boolean} = {};\n  /** The set of namespaces that have already been emitted (through classes or modules). */\n  private emittedNamespaces: ts.Map<boolean> = {};\n\n  constructor(private program: ts.Program, file: ts.SourceFile, private options: Options) {\n    super(file);\n  }\n\n  annotate(): Output {\n    this.visit(this.file);\n    let externs: string = null;\n    if (this.externsOutput.length > 0) {\n      externs = '/** @externs */\\n' + this.externsOutput.join('');\n    }\n    let {output, diagnostics} = this.getOutput();\n    return {\n      output,\n      externs,\n      diagnostics: diagnostics,\n    };\n  }\n\n  /**\n   * Examines a ts.Node and decides whether to do special processing of it for output.\n   *\n   * @return True if the ts.Node has been handled, false if we should\n   *     emit it as is and visit its children.\n   */\n  maybeProcess(node: ts.Node): boolean {\n    if (node.flags & ts.NodeFlags.Ambient) {\n      this.visitExterns(node);\n      // An ambient declaration declares types for TypeScript's benefit, so we want to skip Tsickle\n      // conversion of its contents.\n      this.writeRange(node.getFullStart(), node.getEnd());\n      return true;\n    }\n\n    switch (node.kind) {\n      case ts.SyntaxKind.ExportDeclaration:\n        let exportDecl = <ts.ExportDeclaration>node;\n        if (!exportDecl.exportClause && exportDecl.moduleSpecifier) {\n          // It's an \"export * from ...\" statement.\n          // Rewrite it to re-export each exported symbol directly.\n          let exports = this.expandSymbolsFromExportStar(exportDecl);\n          this.writeRange(exportDecl.getFullStart(), exportDecl.getStart());\n          this.emit(`export {${exports.join(',')}} from`);\n          this.writeRange(exportDecl.moduleSpecifier.getFullStart(), node.getEnd());\n          return true;\n        }\n        return false;\n      case ts.SyntaxKind.InterfaceDeclaration:\n        this.writeRange(node.getFullStart(), node.getEnd());\n        return true;\n      case ts.SyntaxKind.VariableDeclaration:\n        let varDecl = node as ts.VariableDeclaration;\n        // Only emit a type annotation when it's a plain variable and\n        // not a binding pattern, as Closure doesn't(?) have a syntax\n        // for annotating binding patterns.  See issue #128.\n        if (varDecl.name.kind === ts.SyntaxKind.Identifier) {\n          this.emitJSDocType(varDecl);\n        }\n        return false;\n      case ts.SyntaxKind.ClassDeclaration:\n        let classNode = <ts.ClassDeclaration>node;\n        if (classNode.members.length > 0) {\n          // We must visit all members individually, to strip out any\n          // /** @export */ annotations that show up in the constructor\n          // and to annotate methods.\n          this.writeRange(classNode.getFullStart(), classNode.members[0].getFullStart());\n          for (let member of classNode.members) {\n            this.visit(member);\n          }\n        } else {\n          this.writeRange(classNode.getFullStart(), classNode.getLastToken().getFullStart());\n        }\n        this.emitTypeAnnotationsHelper(classNode);\n        this.writeNode(classNode.getLastToken());\n        return true;\n      case ts.SyntaxKind.PublicKeyword:\n      case ts.SyntaxKind.PrivateKeyword:\n        // The \"public\"/\"private\" keywords are encountered in two places:\n        // 1) In class fields (which don't appear in the transformed output).\n        // 2) In \"parameter properties\", e.g.\n        //      constructor(/** @export */ public foo: string).\n        // In case 2 it's important to not emit that JSDoc in the generated\n        // constructor, as this is illegal for Closure.  It's safe to just\n        // always skip comments preceding the 'public' keyword.\n        // See test_files/parameter_properties.ts.\n        this.writeNode(node, /* skipComments */ true);\n        return true;\n      case ts.SyntaxKind.Constructor:\n        let ctor = <ts.ConstructorDeclaration>node;\n        this.emitFunctionType(ctor);\n        // Write the \"constructor(...) {\" bit, but iterate through any\n        // parameters if given so that we can examine them more closely.\n        let offset = ctor.getStart();\n        if (ctor.parameters.length) {\n          for (let param of ctor.parameters) {\n            this.writeRange(offset, param.getFullStart());\n            this.visit(param);\n            offset = param.getEnd();\n          }\n        }\n        this.writeRange(offset, node.getEnd());\n        return true;\n      case ts.SyntaxKind.ArrowFunction:\n        // It's difficult to annotate arrow functions due to a bug in\n        // TypeScript (see tsickle issue 57).  For now, just pass them\n        // through unannotated.\n        return false;\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.MethodDeclaration:\n        let fnDecl = <ts.FunctionLikeDeclaration>node;\n\n        if (!fnDecl.body) {\n          // Functions are allowed to not have bodies in the presence\n          // of overloads.  It's not clear how to translate these overloads\n          // into Closure types, so skip them for now.\n          return false;\n        }\n\n        this.emitFunctionType(fnDecl);\n        this.writeRange(fnDecl.getStart(), fnDecl.body.getFullStart());\n        this.visit(fnDecl.body);\n        return true;\n      case ts.SyntaxKind.TypeAliasDeclaration:\n        this.visitTypeAlias(<ts.TypeAliasDeclaration>node);\n        this.writeNode(node);\n        return true;\n      case ts.SyntaxKind.EnumDeclaration:\n        return this.maybeProcessEnum(<ts.EnumDeclaration>node);\n      case ts.SyntaxKind.TypeAssertionExpression:\n        let typeAssertion = <ts.TypeAssertion>node;\n        this.emitJSDocType(typeAssertion);\n        // When TypeScript emits JS, it removes one layer of \"redundant\"\n        // parens, but we need them for the Closure type assertion.  Work\n        // around this by using two parens.  See test_files/coerce.*.\n        this.emit('((');\n        this.writeNode(node);\n        this.emit('))');\n        return true;\n      default:\n        break;\n    }\n    return false;\n  }\n\n  private expandSymbolsFromExportStar(exportDecl: ts.ExportDeclaration): string[] {\n    let typeChecker = this.program.getTypeChecker();\n\n    // Gather the names of local exports, to avoid reexporting any\n    // names that are already locally exported.\n    // To find symbols declared like\n    //   export {foo} from ...\n    // we must also query for \"Alias\", but that unfortunately also brings in\n    //   import {foo} from ...\n    // so the latter is filtered below.\n    let locals =\n        typeChecker.getSymbolsInScope(this.file, ts.SymbolFlags.Export | ts.SymbolFlags.Alias);\n    let localSet: {[name: string]: boolean} = {};\n    for (let local of locals) {\n      if (local.declarations.some(d => d.kind === ts.SyntaxKind.ImportSpecifier)) {\n        continue;\n      }\n      localSet[local.name] = true;\n    }\n\n    // Expand the export list, then filter it to the symbols we want\n    // to reexport\n    let exports =\n        typeChecker.getExportsOfModule(typeChecker.getSymbolAtLocation(exportDecl.moduleSpecifier));\n    let reexports: {[name: string]: boolean} = {};\n    for (let sym of exports) {\n      let name = sym.name;\n      if (localSet.hasOwnProperty(name)) {\n        // This name is shadowed by a local definition, such as:\n        // - export var foo ...\n        // - export {foo} from ...\n        continue;\n      }\n      if (this.generatedExports.hasOwnProperty(name)) {\n        // Already exported via an earlier expansion of an \"export * from ...\".\n        continue;\n      }\n      this.generatedExports[name] = true;\n      reexports[name] = true;\n    }\n\n    return Object.keys(reexports);\n  }\n\n  private emitFunctionType(fnDecl: ts.FunctionLikeDeclaration, extraTags: JSDocTag[] = []) {\n    let typeChecker = this.program.getTypeChecker();\n    let sig = typeChecker.getSignatureFromDeclaration(fnDecl);\n\n    // Construct the JSDoc comment by reading the existing JSDoc, if\n    // any, and merging it with the known types of the function\n    // parameters and return type.\n    let jsDoc = this.getJSDoc(fnDecl) || {tags: []};\n    let newDoc: JSDocComment = {tags: extraTags};\n\n    // Copy all the tags other than @param/@return into the new\n    // comment without any change; @param/@return are handled later.\n    for (let tag of jsDoc.tags) {\n      if (tag.tagName === 'param' || tag.tagName === 'return') continue;\n      newDoc.tags.push(tag);\n    }\n\n    // Parameters.\n    if (sig.parameters.length) {\n      // Iterate through both the AST parameter list and the type's parameter\n      // list, as some information is only available in the former.\n      for (let i = 0; i < sig.parameters.length; i++) {\n        let paramNode = fnDecl.parameters[i];\n        let paramSym = sig.parameters[i];\n        let type = typeChecker.getTypeOfSymbolAtLocation(paramSym, fnDecl);\n\n        let newTag: JSDocTag = {\n          tagName: 'param',\n          optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,\n          parameterName: paramSym.name,\n        };\n\n        let destructuring =\n            (paramNode.name.kind === ts.SyntaxKind.ArrayBindingPattern ||\n             paramNode.name.kind === ts.SyntaxKind.ObjectBindingPattern);\n\n        if (paramNode.dotDotDotToken !== undefined) {\n          newTag.restParam = true;\n          // In TypeScript you write \"...x: number[]\", but in Closure\n          // you don't write the array: \"@param {...number} x\".  Unwrap\n          // the Array<> wrapper.\n          type = (type as ts.TypeReference).typeArguments[0];\n        }\n\n        newTag.type = this.typeToClosure(fnDecl, type, destructuring);\n\n        // Search for this parameter in the JSDoc @params.\n        for (let {tagName, parameterName, text} of jsDoc.tags) {\n          if (tagName === 'param' && parameterName === paramSym.name) {\n            newTag.text = text;\n            break;\n          }\n        }\n        newDoc.tags.push(newTag);\n      }\n    }\n\n    // Return type.\n    if (fnDecl.kind !== ts.SyntaxKind.Constructor) {\n      let retType = typeChecker.getReturnTypeOfSignature(sig);\n      let returnDoc: string;\n      for (let {tagName, text} of jsDoc.tags) {\n        if (tagName === 'return') {\n          returnDoc = text;\n          break;\n        }\n      }\n      newDoc.tags.push({\n        tagName: 'return',\n        type: this.typeToClosure(fnDecl, retType),\n        text: returnDoc,\n      });\n    }\n\n    // The first \\n makes the output sometimes uglier than necessary,\n    // but it's needed to work around\n    // https://github.com/Microsoft/TypeScript/issues/6982\n    this.emit('\\n/**\\n');\n    for (let tag of newDoc.tags) {\n      this.emit(' * ');\n      if (tag.tagName) {\n        this.emit(`@${tag.tagName}`);\n      }\n      if (tag.type) {\n        this.emit(' {');\n        if (tag.restParam) {\n          this.emit('...');\n        }\n        this.emit(tag.type);\n        if (tag.optional) {\n          this.emit('=');\n        }\n        this.emit('}');\n      }\n      if (tag.parameterName) {\n        this.emit(' ' + tag.parameterName);\n      }\n      if (tag.text) {\n        this.emit(' ' + tag.text);\n      }\n      this.emit('\\n');\n    }\n    this.emit(' */\\n');\n  }\n\n  // emitTypeAnnotationsHelper produces a\n  // _tsickle_typeAnnotationsHelper() where none existed in the\n  // original source.  It's necessary in the case where TypeScript\n  // syntax specifies there are additional properties on the class,\n  // because to declare these in Closure you must declare these in a\n  // method somewhere.\n  private emitTypeAnnotationsHelper(classDecl: ts.ClassDeclaration) {\n    // Gather parameter properties from the constructor, if it exists.\n    let ctors: ts.ConstructorDeclaration[] = [];\n    let paramProps: ts.ParameterDeclaration[] = [];\n    let nonStaticProps: ts.PropertyDeclaration[] = [];\n    let staticProps: ts.PropertyDeclaration[] = [];\n    for (let member of classDecl.members) {\n      if (member.kind === ts.SyntaxKind.Constructor) {\n        ctors.push(member as ts.ConstructorDeclaration);\n      } else if (member.kind === ts.SyntaxKind.PropertyDeclaration) {\n        let prop = member as ts.PropertyDeclaration;\n        let isStatic = (prop.flags & ts.NodeFlags.Static) !== 0;\n        if (isStatic) {\n          staticProps.push(prop);\n        } else {\n          nonStaticProps.push(prop);\n        }\n      }\n    }\n\n    if (ctors.length > 0) {\n      let ctor = ctors[0];\n      paramProps = ctor.parameters.filter((p) => !!(p.flags & VISIBILITY_FLAGS));\n    }\n\n    if (nonStaticProps.length === 0 && paramProps.length === 0 && staticProps.length === 0) {\n      // There are no members so we don't need to emit any type\n      // annotations helper.\n      return;\n    }\n\n    this.emit('\\n\\n  static _tsickle_typeAnnotationsHelper() {\\n');\n    staticProps.forEach(p => this.visitProperty([classDecl.name.text], p));\n    let memberNamespace = [classDecl.name.text, 'prototype'];\n    nonStaticProps.forEach((p) => this.visitProperty(memberNamespace, p));\n    paramProps.forEach((p) => this.visitProperty(memberNamespace, p));\n    this.emit('  }\\n');\n  }\n\n  private visitProperty(namespace: string[], p: ts.PropertyDeclaration|ts.ParameterDeclaration) {\n    let jsDoc = this.getJSDoc(p) || {tags: []};\n    let existingAnnotation = '';\n    for (let {tagName, text} of jsDoc.tags) {\n      if (tagName) {\n        existingAnnotation += `@${tagName}\\n`;\n      } else {\n        existingAnnotation += `${text}\\n`;\n      }\n    }\n    this.emit(' /**');\n    if (existingAnnotation) {\n      this.emit(' ' + existingAnnotation);\n    }\n    this.emit(` @type {${this.typeToClosure(p)}} */\\n`);\n    namespace = namespace.concat([p.name.getText()]);\n    this.emit(`${namespace.join('.')};\\n`);\n  }\n\n  /**\n   * Returns null if there is no existing comment.\n   */\n  private getJSDoc(node: ts.Node): JSDocComment {\n    let text = node.getFullText();\n    let comments = ts.getLeadingCommentRanges(text, 0);\n\n    if (!comments || comments.length === 0) return null;\n\n    // JS compiler only considers the last comment significant.\n    let {pos, end} = comments[comments.length - 1];\n    let comment = text.substring(pos, end);\n    try {\n      return getJSDocAnnotation(comment);\n    } catch (e) {\n      this.error(node, e.message, node.getFullStart() + pos);\n      return null;\n    }\n  }\n\n  private visitExterns(node: ts.Node, namespace: string[] = []) {\n    let originalOutput = this.output;\n    this.output = this.externsOutput;\n    switch (node.kind) {\n      case ts.SyntaxKind.ModuleDeclaration:\n        let decl = <ts.ModuleDeclaration>node;\n        switch (decl.name.kind) {\n          case ts.SyntaxKind.Identifier:\n            // E.g. \"declare namespace foo {\"\n            namespace = namespace.concat(decl.name.text);\n            let nsName = namespace.join('.');\n            if (!this.emittedNamespaces.hasOwnProperty(nsName)) {\n              this.emit('/** @const */\\n');\n              if (namespace.length > 1) {\n                this.emit(`${namespace.join('.')} = {};\\n`);\n              } else {\n                this.emit(`var ${namespace} = {};\\n`);\n              }\n            }\n            this.emittedNamespaces[nsName] = true;\n            this.visitExterns(decl.body, namespace);\n            break;\n          case ts.SyntaxKind.StringLiteral:\n            // E.g. \"declare module 'foo' {\" (note the quotes).\n            // Skip it.\n            break;\n          default:\n            this.errorUnimplementedKind(decl.name, 'externs generation of namespace');\n        }\n        break;\n      case ts.SyntaxKind.ModuleBlock:\n        let block = <ts.ModuleBlock>node;\n        for (let stmt of block.statements) {\n          this.visitExterns(stmt, namespace);\n        }\n        break;\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n        this.writeExternsType(<ts.InterfaceDeclaration|ts.ClassDeclaration>node, namespace);\n        break;\n      case ts.SyntaxKind.FunctionDeclaration:\n        let f = <ts.FunctionDeclaration>node;\n        this.emitFunctionType(f);\n        let params = f.parameters.map((p) => p.name.getText());\n        this.writeExternsFunction(f.name.getText(), params.join(', '), namespace);\n        break;\n      case ts.SyntaxKind.VariableStatement:\n        for (let decl of (<ts.VariableStatement>node).declarationList.declarations) {\n          this.writeExternsVariable(decl, namespace);\n        }\n        break;\n      default:\n        this.emit(`\\n/* TODO: ${ts.SyntaxKind[node.kind]} in ${namespace.join('.')} */\\n`);\n        break;\n    }\n    this.output = originalOutput;\n  }\n\n  private writeExternsType(decl: ts.InterfaceDeclaration|ts.ClassDeclaration, namespace: string[]) {\n    let typeName = namespace.concat([decl.name.getText()]).join('.');\n    this.emittedNamespaces[typeName] = true;\n    if (closureExternsBlacklist.indexOf(typeName) >= 0) return;\n    this.emittedNamespaces[typeName] = true;\n\n    let paramNames = '';\n    if (decl.kind === ts.SyntaxKind.ClassDeclaration) {\n      let ctors =\n          (<ts.ClassDeclaration>decl).members.filter((m) => m.kind === ts.SyntaxKind.Constructor);\n      if (ctors.length) {\n        if (ctors.length > 1) {\n          this.error(ctors[1], 'multiple constructor signatures in declarations');\n        }\n        let ctor = <ts.ConstructorDeclaration>ctors[0];\n        this.emitFunctionType(ctor, [{tagName: 'constructor'}, {tagName: 'struct'}]);\n        paramNames = ctor.parameters.map((p) => p.name.getText()).join(', ');\n      } else {\n        this.emit('/** @constructor @struct */\\n');\n      }\n    } else {\n      this.emit('/** @record @struct */\\n');\n    }\n\n    this.writeExternsFunction(decl.name.getText(), paramNames, namespace);\n\n    for (let member of decl.members) {\n      switch (member.kind) {\n        case ts.SyntaxKind.PropertySignature:\n        case ts.SyntaxKind.PropertyDeclaration:\n          let prop = <ts.PropertySignature>member;\n          this.emitJSDocType(prop);\n          this.emit(`\\n${typeName}.prototype.${prop.name.getText()};\\n`);\n          break;\n        case ts.SyntaxKind.MethodDeclaration:\n          let m = <ts.MethodDeclaration>member;\n          this.emitFunctionType(m);\n          this.emit(\n              `${typeName}.prototype.${m.name.getText()} = ` +\n              `function(${m.parameters.map((p) => p.name.getText()).join(', ')}) {};\\n`);\n          break;\n        case ts.SyntaxKind.Constructor:\n          break;  // Handled above.\n        default:\n          // Members can include things like index signatures, for e.g.\n          //   interface Foo { [key: string]: number; }\n          // For now, just die unless all the members are regular old\n          // properties.\n          let name = namespace;\n          if (member.name) {\n            name = name.concat([member.name.getText()]);\n          }\n          this.emit(`\\n/* TODO: ${ts.SyntaxKind[member.kind]} in ${name.join('.')} */\\n`);\n      }\n    }\n  }\n\n  private writeExternsVariable(decl: ts.VariableDeclaration, namespace: string[]) {\n    if (decl.name.kind === ts.SyntaxKind.Identifier) {\n      let identifier = <ts.Identifier>decl.name;\n      let qualifiedName = namespace.concat([identifier.text]).join('.');\n      if (closureExternsBlacklist.indexOf(qualifiedName) >= 0) return;\n      this.emitJSDocType(decl);\n      if (namespace.length > 0) {\n        this.emit(`\\n${qualifiedName};\\n`);\n      } else {\n        this.emit(`\\nvar ${qualifiedName};\\n`);\n      }\n    } else {\n      this.errorUnimplementedKind(decl.name, 'externs for variable');\n    }\n  }\n\n  private writeExternsFunction(name: string, params: string, namespace: string[]) {\n    if (namespace.length > 0) {\n      name = namespace.concat([name]).join('.');\n      this.emit(`${name} = function(${params}) {};\\n`);\n    } else {\n      this.emit(`function ${name}(${params}) {}\\n`);\n    }\n  }\n\n  /** Emits a type annotation in JSDoc, or {?} if the type is unavailable. */\n  private emitJSDocType(node: ts.Node, additionalDocTag?: string) {\n    this.emit(' /**');\n    if (additionalDocTag) {\n      this.emit(' ' + additionalDocTag);\n    }\n    this.emit(` @type {${this.typeToClosure(node)}} */`);\n  }\n\n  /**\n   * Convert a TypeScript ts.Type into the equivalent Closure type.\n   *\n   * @param context The ts.Node containing the type reference; used for resolving symbols\n   *     in context.\n   * @param type The type to translate; if not provided, the Node's type will be used.\n   * @param destructuring If true, insert a Closure \"!\" (not-null annotation) on all\n   *     object/array types.  This is a workaround specifically for destructuring\n   *     bind patterns.\n   */\n  private typeToClosure(context: ts.Node, type?: ts.Type, destructuring?: boolean): string {\n    if (this.options.untyped) {\n      return '?';\n    }\n\n    let typeChecker = this.program.getTypeChecker();\n    if (!type) {\n      type = typeChecker.getTypeAtLocation(context);\n    }\n    let translator = new TypeTranslator(typeChecker, context);\n    translator.warn = msg => this.debugWarn(context, msg);\n    return translator.translate(type, destructuring);\n  }\n\n  private visitTypeAlias(node: ts.TypeAliasDeclaration) {\n    if (this.options.untyped) return;\n    // Write a Closure typedef, which involves an unused \"var\" declaration.\n    this.emit(`/** @typedef {${this.typeToClosure(node)}} */\\n`);\n    this.emit(`var ${node.name.getText()}: void;\\n`);\n  }\n\n  /** Processes an EnumDeclaration or returns false for ordinary processing. */\n  private maybeProcessEnum(node: ts.EnumDeclaration): boolean {\n    if (node.flags & ts.NodeFlags.Const) {\n      // const enums disappear after TS compilation and consequently need no\n      // help from tsickle.\n      return false;\n    }\n\n    // Gather the members of enum, saving the constant value or\n    // initializer expression in the case of a non-constant value.\n    let members: {[name: string]: number | ts.Node} = {};\n    let i = 0;\n    for (let member of node.members) {\n      let memberName = member.name.getText();\n      if (member.initializer) {\n        let enumConstValue = this.program.getTypeChecker().getConstantValue(member);\n        if (enumConstValue !== undefined) {\n          members[memberName] = enumConstValue;\n          i = enumConstValue + 1;\n        } else {\n          // Non-constant enum value.  Save the initializer expression for\n          // emitting as-is.\n          // Note: if the member's initializer expression refers to another\n          // value within the enum (e.g. something like\n          //   enum Foo {\n          //     Field1,\n          //     Field2 = Field1 + something(),\n          //   }\n          // Then when we emit the initializer we produce invalid code because\n          // on the Closure side it has to be written \"Foo.Field1 + something()\".\n          // Hopefully this doesn't come up often -- if the enum instead has\n          // something like\n          //     Field2 = Field1 + 3,\n          // then it's still a constant expression and we inline the constant\n          // value in the above branch of this \"if\" statement.\n          members[memberName] = member.initializer;\n        }\n      } else {\n        members[memberName] = i;\n        i++;\n      }\n    }\n\n    // Emit the enum declaration, which looks like:\n    //   type Foo = number;\n    //   let Foo: any = {};\n    // We use an \"any\" here rather than a more specific type because\n    // we think TypeScript has already checked types for us, and it's\n    // a bit difficult to provide a type that matches all the interfaces\n    // expected of an enum (in particular, it is keyable both by\n    // string and number).\n    // We don't emit a specific Closure type for the enum because it's\n    // also difficult to make work: for example, we can't make the name\n    // both a typedef and an indexable object if we export it.\n    this.emit('\\n');\n    let name = node.name.getText();\n    if (node.flags & ts.NodeFlags.Export) {\n      this.emit('export ');\n    }\n    this.emit(`type ${name} = number;\\n`);\n    if (node.flags & ts.NodeFlags.Export) {\n      this.emit('export ');\n    }\n    this.emit(`let ${name}: any = {};\\n`);\n\n    // Emit foo.BAR = 0; lines.\n    for (let member of Object.keys(members)) {\n      if (!this.options.untyped) this.emit(`/** @type {number} */\\n`);\n      this.emit(`${name}.${member} = `);\n      let value = members[member];\n      if (typeof value === 'number') {\n        this.emit(value.toString());\n      } else {\n        this.visit(value);\n      }\n      this.emit(';\\n');\n    }\n\n    // Emit foo[foo.BAR] = 'BAR'; lines.\n    for (let member of Object.keys(members)) {\n      this.emit(`${name}[${name}.${member}] = \"${member}\";\\n`);\n    }\n\n    return true;\n  }\n\n  /**\n   * debug logs a debug warning.  These should only be used for cases\n   * where tsickle is making a questionable judgement about what to do.\n   * By default, tsickle does not report any warnings to the caller,\n   * and warnings are hidden behind a debug flag, as warnings are only\n   * for tsickle to debug itself.\n   */\n  private debugWarn(node: ts.Node, messageText: string) {\n    if (!this.options.logWarning) return;\n    // Use a ts.Diagnosic so that the warning includes context and file offets.\n    let diagnostic: ts.Diagnostic = {\n      file: this.file,\n      start: node.getStart(),\n      length: node.getEnd() - node.getStart(), messageText,\n      category: ts.DiagnosticCategory.Warning,\n      code: undefined,\n    };\n    this.options.logWarning(diagnostic);\n  }\n}\n\nexport function annotate(program: ts.Program, file: ts.SourceFile, options: Options = {}): Output {\n  return new Annotator(program, file, options).annotate();\n}\n\n/**\n * PostProcessor postprocesses TypeScript compilation output JS, to rewrite commonjs require()s into\n * goog.require().\n */\nclass PostProcessor extends Rewriter {\n  /**\n   * namespaceImports collects the variables for imported goog.modules.\n   * If the original TS input is:\n   *   import foo from 'goog:bar';\n   * then TS produces:\n   *   var foo = require('goog:bar');\n   * and this class rewrites it to:\n   *   var foo = require('goog.bar');\n   * After this step, namespaceImports['foo'] is true.\n   * (This is used to rewrite 'foo.default' into just 'foo'.)\n   */\n  namespaceImports: {[varName: string]: boolean} = {};\n\n  /**\n   * moduleVariables maps from module names to the variables they're assigned to.\n   * Continuing the above example, moduleVariables['goog.bar'] = 'foo'.\n   */\n  moduleVariables: {[moduleName: string]: string} = {};\n\n  /** strippedStrict is true once we've stripped a \"use strict\"; from the input. */\n  strippedStrict: boolean = false;\n\n  /** unusedIndex is used to generate fresh symbols for unnamed imports. */\n  unusedIndex: number = 0;\n\n  constructor(\n      file: ts.SourceFile,\n      private pathToModuleName: (context: string, fileName: string) => string) {\n    super(file);\n  }\n\n  process(): {output: string, referencedModules: string[]} {\n    // TODO(evanm): only emit the goog.module *after* the first comment,\n    // so that @suppress statements work.\n    const moduleName = this.pathToModuleName('', this.file.fileName);\n    // NB: No linebreak after module call so sourcemaps are not offset.\n    this.emit(`goog.module('${moduleName}');`);\n\n    let pos = 0;\n    for (let stmt of this.file.statements) {\n      this.writeRange(pos, stmt.getFullStart());\n      this.visitTopLevel(stmt);\n      pos = stmt.getEnd();\n    }\n    this.writeRange(pos, this.file.getEnd());\n\n    let referencedModules = Object.keys(this.moduleVariables);\n    // Note: don't sort referencedModules, as the keys are in the same order\n    // they occur in the source file.\n    let {output} = this.getOutput();\n    return {output, referencedModules};\n  }\n\n  /**\n   * visitTopLevel processes a top-level ts.Node and emits its contents.\n   *\n   * It's separate from the normal Rewriter recursive traversal\n   * because some top-level statements are handled specially.\n   */\n  visitTopLevel(node: ts.Node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.ExpressionStatement:\n        // Check for \"use strict\" and skip it if necessary.\n        if (!this.strippedStrict && this.isUseStrict(node)) {\n          this.writeRange(node.getFullStart(), node.getStart());\n          this.strippedStrict = true;\n          return;\n        }\n        // Check for:\n        // - \"require('foo');\" (a require for its side effects)\n        // - \"__export(require(...));\" (an \"export * from ...\")\n        if (this.emitRewrittenRequires(node)) {\n          return;\n        }\n        // Otherwise fall through to default processing.\n        break;\n      case ts.SyntaxKind.VariableStatement:\n        // Check for a \"var x = require('foo');\".\n        if (this.emitRewrittenRequires(node)) return;\n        break;\n      default:\n        break;\n    }\n    this.visit(node);\n  }\n\n  /** isUseStrict returns true if node is a \"use strict\"; statement. */\n  isUseStrict(node: ts.Node): boolean {\n    if (node.kind !== ts.SyntaxKind.ExpressionStatement) return false;\n    let exprStmt = node as ts.ExpressionStatement;\n    let expr = exprStmt.expression;\n    if (expr.kind !== ts.SyntaxKind.StringLiteral) return false;\n    let literal = expr as ts.StringLiteral;\n    return literal.text === 'use strict';\n  }\n\n  /**\n   * emitRewrittenRequires rewrites require()s into goog.require() equivalents.\n   *\n   * @return True if the node was rewritten, false if needs ordinary processing.\n   */\n  emitRewrittenRequires(node: ts.Node): boolean {\n    // We're looking for requires, of one of the forms:\n    // - \"var importName = require(...);\".\n    // - \"require(...);\".\n    // Find the CallExpression contained in either of these.\n    let varName: string;          // E.g. importName in the above example.\n    let call: ts.CallExpression;  // The require(...) expression.\n    if (node.kind === ts.SyntaxKind.VariableStatement) {\n      // It's possibly of the form \"var x = require(...);\".\n      let varStmt = node as ts.VariableStatement;\n\n      // Verify it's a single decl (and not \"var x = ..., y = ...;\").\n      if (varStmt.declarationList.declarations.length !== 1) return false;\n      let decl = varStmt.declarationList.declarations[0];\n\n      // Grab the variable name (avoiding things like destructuring binds).\n      if (decl.name.kind !== ts.SyntaxKind.Identifier) return false;\n      varName = (decl.name as ts.Identifier).text;\n      if (!decl.initializer || decl.initializer.kind !== ts.SyntaxKind.CallExpression) return false;\n      call = decl.initializer as ts.CallExpression;\n    } else if (node.kind === ts.SyntaxKind.ExpressionStatement) {\n      // It's possibly of the form:\n      // - require(...);\n      // - __export(require(...));\n      // Both are CallExpressions.\n      let exprStmt = node as ts.ExpressionStatement;\n      let expr = exprStmt.expression;\n      if (expr.kind !== ts.SyntaxKind.CallExpression) return false;\n      call = expr as ts.CallExpression;\n\n      let require = this.isExportRequire(call);\n      if (require) {\n        let modName = this.pathToModuleName(this.file.fileName, require);\n        this.writeRange(node.getFullStart(), node.getStart());\n        this.emit(`__export(goog.require('${modName}'));`);\n        // Mark that this module was imported; it doesn't have an associated\n        // variable so just call the variable \"*\".\n        this.moduleVariables[modName] = '*';\n        return true;\n      }\n    } else {\n      // It's some other type of statement.\n      return false;\n    }\n\n    let require = this.isRequire(call);\n    if (!require) return false;\n\n    // Even if it's a bare require(); statement, introduce a variable for it.\n    // This avoids a Closure error.\n    if (!varName) {\n      varName = `unused_${this.unusedIndex++}_`;\n    }\n\n    let modName: string;\n    if (require.match(/^goog:/)) {\n      // This is a namespace import, of the form \"goog:foo.bar\".\n      // Fix it to just \"foo.bar\", and save the variable name.\n      modName = require.substr(5);\n      this.namespaceImports[varName] = true;\n    } else {\n      modName = this.pathToModuleName(this.file.fileName, require);\n    }\n\n    this.writeRange(node.getFullStart(), node.getStart());\n    if (this.moduleVariables.hasOwnProperty(modName)) {\n      this.emit(`var ${varName} = ${this.moduleVariables[modName]};`);\n    } else {\n      this.emit(`var ${varName} = goog.require('${modName}');`);\n      this.moduleVariables[modName] = varName;\n    }\n    return true;\n  }\n\n  /**\n   * Returns the string argument if call is of the form\n   *   require('foo')\n   */\n  isRequire(call: ts.CallExpression): string {\n    // Verify that the call is a call to require(...).\n    if (call.expression.kind !== ts.SyntaxKind.Identifier) return null;\n    let ident = call.expression as ts.Identifier;\n    if (ident.text !== 'require') return null;\n\n    // Verify the call takes a single string argument and grab it.\n    if (call.arguments.length !== 1) return null;\n    let arg = call.arguments[0];\n    if (arg.kind !== ts.SyntaxKind.StringLiteral) return null;\n    return (arg as ts.StringLiteral).text;\n  }\n\n  /**\n   * Returns the inner string if call is of the form\n   *   __export(require('foo'))\n   */\n  isExportRequire(call: ts.CallExpression): string {\n    if (call.expression.kind !== ts.SyntaxKind.Identifier) return null;\n    let ident = call.expression as ts.Identifier;\n    if (ident.getText() !== '__export') return null;\n\n    // Verify the call takes a single string argument and grab it.\n    if (call.arguments.length !== 1) return null;\n    let arg = call.arguments[0];\n    if (arg.kind !== ts.SyntaxKind.CallExpression) return null;\n    return this.isRequire(arg as ts.CallExpression);\n  }\n\n  /**\n   * maybeProcess is called during the recursive traversal of the program's AST.\n   *\n   * @return True if the node was processed/emitted, false if it should be emitted as is.\n   */\n  protected maybeProcess(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.PropertyAccessExpression:\n        let propAccess = node as ts.PropertyAccessExpression;\n        // We're looking for an expression of the form:\n        //   module_name_var.default\n        if (propAccess.name.text !== 'default') break;\n        if (propAccess.expression.kind !== ts.SyntaxKind.Identifier) break;\n        let lhsIdent = propAccess.expression as ts.Identifier;\n        if (!this.namespaceImports.hasOwnProperty(lhsIdent.text)) break;\n        // Emit the same expression, with spaces to replace the \".default\" part\n        // so that source maps still line up.\n        this.writeRange(node.getFullStart(), node.getStart());\n        this.emit(`${lhsIdent.text}        `);\n        return true;\n      default:\n        break;\n    }\n    return false;\n  }\n}\n\n/**\n * Converts TypeScript's JS+CommonJS output to Closure goog.module etc.\n * For use as a postprocessing step *after* TypeScript emits JavaScript.\n *\n * @param fileName The source file name, without an extension.\n * @param pathToModuleName A function that maps a filesystem .ts path to a\n *     Closure module name, as found in a goog.require('...') statement.\n *     The context parameter is the referencing file, used for resolving\n *     imports with relative paths like \"import * as foo from '../foo';\".\n */\nexport function convertCommonJsToGoogModule(\n    fileName: string, content: string, pathToModuleName: (context: string, fileName: string) =>\n                                           string): {output: string, referencedModules: string[]} {\n  let file = ts.createSourceFile(fileName, content, ts.ScriptTarget.ES5, true);\n  return new PostProcessor(file, pathToModuleName).process();\n}\n"],"sourceRoot":"/source/"}