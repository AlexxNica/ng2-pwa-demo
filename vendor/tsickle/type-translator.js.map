{"version":3,"sources":["type-translator.ts"],"names":[],"mappings":"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","file":"type-translator.js","sourcesContent":["import * as ts from 'typescript';\n\nexport function typeToDebugString(type: ts.Type): string {\n  const basicTypes: ts.TypeFlags[] = [\n    ts.TypeFlags.Any,           ts.TypeFlags.String,\n    ts.TypeFlags.Number,        ts.TypeFlags.Boolean,\n    ts.TypeFlags.Void,          ts.TypeFlags.Undefined,\n    ts.TypeFlags.Null,          ts.TypeFlags.Enum,\n    ts.TypeFlags.StringLiteral, ts.TypeFlags.TypeParameter,\n    ts.TypeFlags.Class,         ts.TypeFlags.Interface,\n    ts.TypeFlags.Reference,     ts.TypeFlags.Tuple,\n    ts.TypeFlags.Union,         ts.TypeFlags.Intersection,\n    ts.TypeFlags.Anonymous,     ts.TypeFlags.Instantiated,\n    ts.TypeFlags.ObjectLiteral, ts.TypeFlags.ESSymbol,\n    ts.TypeFlags.ThisType,      ts.TypeFlags.ObjectLiteralPatternWithComputedProperties,\n  ];\n  let names: string[] = [];\n  for (let flag of basicTypes) {\n    if ((type.flags & flag) !== 0) {\n      names.push(ts.TypeFlags[flag]);\n    }\n  }\n\n  // combinedTypes are TypeFlags that represent combined values.\n  // For example, NumberLike = Number|Enum.\n  const combinedTypes: ts.TypeFlags[] = [\n    ts.TypeFlags.StringLike,\n    ts.TypeFlags.NumberLike,\n    ts.TypeFlags.ObjectType,\n    ts.TypeFlags.UnionOrIntersection,\n    ts.TypeFlags.StructuredType,\n  ];\n  let features: string[] = [];\n  for (let flag of combinedTypes) {\n    if ((type.flags & flag) !== 0) {\n      features.push(ts.TypeFlags[flag]);\n    }\n  }\n\n  let debugString = `flags:0x${type.flags.toString(16)}`;\n  debugString += ' ' + names.join(' ');\n  if (features.length > 0) {\n    debugString += ` features:${features.join(',')}`;\n  }\n\n  if (type.symbol && type.symbol.name !== '__type') {\n    debugString += ` symbol.name:${JSON.stringify(type.symbol.name)}`;\n  }\n\n  if (type.pattern) {\n    debugString += ` destructuring:true`;\n  }\n\n  return `{type ${debugString}}`;\n}\n\nexport function symbolToDebugString(sym: ts.Symbol): string {\n  let debugString = `${JSON.stringify(sym.name)} ${sym.flags.toString(16)}`;\n  return `{sym: ${debugString}}`;\n}\n\n/** TypeTranslator translates TypeScript types to Closure types. */\nexport class TypeTranslator {\n  /**\n   * @param node is the source AST ts.Node the type comes from.  This is used\n   *     in some cases (e.g. anonymous types) for looking up field names.\n   */\n  constructor(private typeChecker: ts.TypeChecker, private node: ts.Node) {}\n\n  /**\n   * @param notNull When true, insert a ! before any type references.  This\n   *    is to work around the difference between TS and Closure destructuring.\n   */\n  translate(type: ts.Type, notNull = false): string {\n    // See the function `buildTypeDisplay` in the TypeScript compiler source\n    // for guidance on a similar operation.\n\n    // NOTE: type.flags is a single value for primitive types, but sometimes a\n    // bitwise 'or' of some values for more complex types.  We use a switch\n    // statement for the basics and a series of \"if\" tests for the complex ones,\n    // roughly in the same order the flags occur in the TypeFlags enum.\n    switch (type.flags) {\n      case ts.TypeFlags.Any:\n        return '?';\n      case ts.TypeFlags.String:\n        return 'string';\n      case ts.TypeFlags.Number:\n        return 'number';\n      case ts.TypeFlags.Boolean:\n        return 'boolean';\n      case ts.TypeFlags.Void:\n        return 'void';\n      case ts.TypeFlags.Undefined:\n        return 'undefined';\n      case ts.TypeFlags.Null:\n        return 'null';\n      case ts.TypeFlags.Enum:\n        return 'number';\n      case ts.TypeFlags.StringLiteral:\n        return 'string';\n      default:\n        // Continue on to more complex tests below.\n    }\n\n    let notNullPrefix = notNull ? '!' : '';\n\n    if (type.flags & (ts.TypeFlags.Interface | ts.TypeFlags.Class)) {\n      // Note: ts.InterfaceType has a typeParameters field, but that\n      // specifies the parameters that the interface type *expects*\n      // when it's used, and should not be transformed to the output.\n      // E.g. a type like Array<number> is a TypeReference to the\n      // InterfaceType \"Array\", but the \"number\" type parameter is\n      // part of the outer TypeReference, not a typeParameter on\n      // the InterfaceType.\n      return type.symbol.name;\n    } else if (type.flags & ts.TypeFlags.Reference) {\n      // A reference to another type, e.g. Array<number> refers to Array.\n      // Emit the referenced type and any type arguments.\n      let referenceType = type as ts.TypeReference;\n      if (referenceType.target === referenceType) {\n        // We get into an infinite loop here if the inner reference is\n        // the same as the outer; this can occur when this function\n        // fails to translate a more specific type before getting to\n        // this point.\n        throw new Error(`reference loop in ${typeToDebugString(referenceType)}`);\n      }\n      let typeStr = notNullPrefix + this.translate(referenceType.target);\n      if (referenceType.typeArguments) {\n        let params = referenceType.typeArguments.map(t => this.translate(t, notNull));\n        typeStr += `<${params.join(', ')}>`;\n      }\n      return typeStr;\n    } else if (type.flags & ts.TypeFlags.Anonymous) {\n      if (!type.symbol) {\n        // This comes up when generating code for an arrow function as passed\n        // to a generic function.  The passed-in type is tagged as anonymous\n        // and has no properties so it's hard to figure out what to generate.\n        // Just avoid it for now so we don't crash.\n        this.warn('anonymous type has no symbol');\n        return '?';\n      }\n\n      if (type.symbol.flags === ts.SymbolFlags.TypeLiteral) {\n        return notNullPrefix + this.translateTypeLiteral(type);\n      } else if (type.symbol.flags === ts.SymbolFlags.Function) {\n        let sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);\n        if (sigs.length === 1) {\n          return this.signatureToClosure(sigs[0]);\n        }\n      }\n      this.warn('unhandled anonymous type');\n      return '?';\n    } else if (type.flags & ts.TypeFlags.Union) {\n      let unionType = type as ts.UnionType;\n      let parts = unionType.types.map(t => this.translate(t));\n      return `(${parts.join('|')})`;\n    }\n    this.warn(`unhandled type ${typeToDebugString(type)}`);\n    return '?';\n  }\n\n  private translateTypeLiteral(type: ts.Type): string {\n    // Gather up all the named fields and whether the object is also callable.\n    let callable = false;\n    let indexable = false;\n    let fields: string[] = [];\n    for (let field of Object.keys(type.symbol.members)) {\n      switch (field) {\n        case '__call':\n          callable = true;\n          break;\n        case '__index':\n          indexable = true;\n          break;\n        default:\n          let member = type.symbol.members[field];\n          let isOptional = member.flags & ts.SymbolFlags.Optional;\n          let memberType =\n              this.translate(this.typeChecker.getTypeOfSymbolAtLocation(member, this.node));\n          if (isOptional) {\n            memberType = `(${memberType}|undefined)`;\n          }\n          fields.push(`${field}: ${memberType}`);\n      }\n    }\n\n    // Try to special-case plain key-value objects and functions.\n    if (fields.length === 0) {\n      if (callable && !indexable) {\n        // A function type.\n        let sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);\n        if (sigs.length === 1) {\n          return this.signatureToClosure(sigs[0]);\n        }\n      } else if (indexable && !callable) {\n        // A plain key-value map type.\n        let keyType = 'string';\n        let valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.String);\n        if (!valType) {\n          keyType = 'number';\n          valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.Number);\n        }\n        if (!valType) {\n          this.warn('unknown index key type');\n          return `Object<?,?>`;\n        }\n        return `Object<${keyType},${this.translate(valType)}>`;\n      } else if (!callable && !indexable) {\n        // Special-case the empty object {} because Closure doesn't like it.\n        // TODO(evanm): revisit this if it is a problem.\n        return 'Object';\n      }\n    }\n\n    if (!callable && !indexable) {\n      // Not callable, not indexable; implies a plain object with fields in it.\n      return `{${fields.join(', ')}}`;\n    }\n\n    this.warn('unhandled type literal');\n    return '?';\n  }\n\n  /** Converts a ts.Signature (function signature) to a Closure function type. */\n  private signatureToClosure(sig: ts.Signature): string {\n    let params: string[] = [];\n    for (let param of sig.parameters) {\n      params.push(this.translate(this.typeChecker.getTypeOfSymbolAtLocation(param, this.node)));\n    }\n    let typeStr = `function(${params.join(', ')})`;\n\n    let retType = this.translate(this.typeChecker.getReturnTypeOfSignature(sig));\n    if (retType) {\n      typeStr += `: ${retType}`;\n    }\n\n    return typeStr;\n  }\n\n  warn(msg: string) {\n    // By default, warn() does nothing.  The caller will overwrite this\n    // if it wants different behavior.\n  }\n}\n"],"sourceRoot":"/source/"}