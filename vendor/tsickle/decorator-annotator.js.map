{"version":3,"sources":["decorator-annotator.ts"],"names":[],"mappings":"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","file":"decorator-annotator.js","sourcesContent":["import * as ts from 'typescript';\nimport {Rewriter} from './rewriter';\n\n// ClassRewriter rewrites a single \"class Foo {...}\" declaration.\n// It's its own object because we collect decorators on the class and the ctor\n// separately for each class we encounter.\nclass ClassRewriter extends Rewriter {\n  /** Decorators on the class itself. */\n  decorators: ts.Decorator[];\n  /** The constructor parameter list and decorators on each param. */\n  ctorParameters: [string, ts.Decorator[]][];\n  /** Per-method decorators. */\n  propDecorators: {[key: string]: ts.Decorator[]};\n\n  /**\n   * process is the main entry point, rewriting a single class node.\n   */\n  process(node: ts.ClassDeclaration): {output: string, diagnostics: ts.Diagnostic[]} {\n    if (node.decorators) {\n      this.decorators = node.decorators.slice();\n    }\n    let pos = node.getFullStart();\n    for (let child of node.getChildren()) {\n      switch (child.kind) {\n        case ts.SyntaxKind.CloseBraceToken:\n          // Before writing the close brace, dump the metadata.\n          this.writeRange(pos, child.getStart());\n          this.emitMetadata();\n          this.writeRange(child.getStart(), child.getEnd());\n          break;\n        default:\n          this.writeRange(pos, child.getFullStart());\n          this.visit(child);\n      }\n      pos = child.getEnd();\n    }\n    return this.getOutput();\n  }\n\n  /**\n   * gatherConstructor grabs the parameter list and decorators off the class\n   * constructor, and emits nothing.\n   */\n  private gatherConstructor(ctor: ts.ConstructorDeclaration) {\n    let ctorParameters: [string, ts.Decorator[]][] = [];\n    let hasDecoratedParam = false;\n    for (let param of ctor.parameters) {\n      let paramCtor: string;\n      let decorators: ts.Decorator[];\n      if (param.decorators) {\n        decorators = param.decorators.slice();\n        hasDecoratedParam = true;\n      }\n      if (param.type) {\n        switch (param.type.kind) {\n          case ts.SyntaxKind.TypeReference:\n            let typeRef = param.type as ts.TypeReferenceNode;\n            // Type reference can be a bare name or a qualified name (foo.bar),\n            // possibly followed by type arguments (<X, Y>).\n            // We are making the assumption that a type reference is the same\n            // name as a ctor for that type, and it's simplest to just use the\n            // source text. We use `typeName` to avoid emitting type parameters.\n            paramCtor = typeRef.typeName.getText();\n            break;\n          default:\n            // Some other type of type; just ignore it.\n        }\n      }\n      if (paramCtor || decorators) {\n        ctorParameters.push([paramCtor, decorators]);\n      } else {\n        ctorParameters.push(null);\n      }\n    }\n\n    // Use the ctor parameter metadata only if the class or the ctor was decorated.\n    if (this.decorators || hasDecoratedParam) {\n      this.ctorParameters = ctorParameters;\n    }\n  }\n\n  /**\n   * gatherMethod grabs the decorators off a class method and emits nothing.\n   */\n  private gatherMethodOrProperty(method: ts.Declaration) {\n    if (!method.decorators) return;\n    if (method.name.kind !== ts.SyntaxKind.Identifier) {\n      // Method has a weird name, e.g.\n      //   [Symbol.foo]() {...}\n      this.error(method, `cannot process decorators on ${ts.SyntaxKind[method.name.kind]}`);\n      return;\n    }\n\n    let name = (method.name as ts.Identifier).text;\n    let decorators: ts.Decorator[] = method.decorators.slice();\n    if (!this.propDecorators) this.propDecorators = {};\n    this.propDecorators[name] = decorators;\n  }\n\n  /**\n   * maybeProcess is called by the traversal of the AST.\n   * @return True if the node was handled, false to have the node emitted as normal.\n   */\n  protected maybeProcess(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n        // Encountered a new class while processing this class; use a new separate\n        // rewriter to gather+emit its metadata.\n        let {output, diagnostics} =\n            new ClassRewriter(this.file).process(node as ts.ClassDeclaration);\n        this.diagnostics.push(...diagnostics);\n        this.emit(output);\n        return true;\n      case ts.SyntaxKind.Constructor:\n        this.gatherConstructor(node as ts.ConstructorDeclaration);\n        return false;  // Proceed with ordinary emit of the ctor.\n      case ts.SyntaxKind.PropertyDeclaration:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.MethodDeclaration:\n        this.gatherMethodOrProperty(node as ts.Declaration);\n        return false;  // Proceed with ordinary emit of the method.\n      case ts.SyntaxKind.Decorator:\n        // Skip emit of all decorators, as they are specially handled.\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * emitMetadata emits the various gathered metadata, as static fields.\n   */\n  private emitMetadata() {\n    if (this.decorators) {\n      this.emit(`static decorators: DecoratorInvocation[] = [\\n`);\n      for (let annotation of this.decorators) {\n        this.emitDecorator(annotation);\n        this.emit(',\\n');\n      }\n      this.emit('];\\n');\n    }\n\n    if (this.ctorParameters) {\n      this.emit(\n          `/** @nocollapse */ static ctorParameters: {type: Function, decorators?: DecoratorInvocation[]}[] = [\\n`);\n      for (let param of this.ctorParameters) {\n        if (!param) {\n          this.emit('null,\\n');\n          continue;\n        }\n        let [ctor, decorators] = param;\n        this.emit(`{type: ${ctor}, `);\n        if (decorators) {\n          this.emit('decorators: [');\n          for (let decorator of decorators) {\n            this.emitDecorator(decorator);\n            this.emit(', ');\n          }\n          this.emit(']');\n        }\n        this.emit('},\\n');\n      }\n      this.emit(`];\\n`);\n    }\n\n    if (this.propDecorators) {\n      this.emit('static propDecorators: {[key: string]: DecoratorInvocation[]} = {\\n');\n      for (let name of Object.keys(this.propDecorators)) {\n        this.emit(`'${name}': [`);\n        for (let decorator of this.propDecorators[name]) {\n          this.emitDecorator(decorator);\n          this.emit(',');\n        }\n        this.emit('],\\n');\n      }\n      this.emit('};\\n');\n    }\n  }\n\n  private emitDecorator(decorator: ts.Decorator) {\n    this.emit('{ type: ');\n    let expr = decorator.expression;\n    switch (expr.kind) {\n      case ts.SyntaxKind.Identifier:\n        // The decorator was a plain @Foo.\n        this.visit(expr);\n        break;\n      case ts.SyntaxKind.CallExpression:\n        // The decorator was a call, like @Foo(bar).\n        let call = expr as ts.CallExpression;\n        this.visit(call.expression);\n        if (call.arguments.length) {\n          this.emit(', args: [');\n          for (let arg of call.arguments) {\n            this.emit(arg.getText());\n            this.emit(', ');\n          }\n          this.emit(']');\n        }\n        break;\n      default:\n        this.errorUnimplementedKind(expr, 'gathering metadata');\n        this.emit('undefined');\n    }\n    this.emit(' }');\n  }\n}\n\nclass DecoratorRewriter extends Rewriter {\n  process(): {output: string, diagnostics: ts.Diagnostic[]} {\n    this.visit(this.file);\n    return this.getOutput();\n  }\n\n  protected maybeProcess(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n        let {output, diagnostics} =\n            new ClassRewriter(this.file).process(node as ts.ClassDeclaration);\n        this.diagnostics.push(...diagnostics);\n        this.emit(output);\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n\nexport function convertDecorators(\n    fileName: string, sourceText: string): {output: string, diagnostics: ts.Diagnostic[]} {\n  let file = ts.createSourceFile(fileName, sourceText, ts.ScriptTarget.ES5, true);\n  return new DecoratorRewriter(file).process();\n}\n"],"sourceRoot":"/source/"}